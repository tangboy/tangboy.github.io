<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="CANAL源码解析-binlog消费位点的控制"/>




  <meta name="keywords" content="canal, Anthon" />










  <link rel="alternate" href="/default" title="Anthon">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.10.1" />



<link rel="canonical" href="http://code-monkey.top/2020/02/07/CANAL源码解析-binlog消费位点的控制/"/>



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  <link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css" />



<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.10.1" />



  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>





  <script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script>
  <script id="leancloud">
    AV.init({
      appId: "MMvtgrWtn9BuiNVh6B529AP5-gzGzoHsz",
      appKey: "bA46NPkYiSG0QaBP2vX2ckzl"
    });
  </script>





<script>
  window.config = {"leancloud":{"app_id":"MMvtgrWtn9BuiNVh6B529AP5-gzGzoHsz","app_key":"bA46NPkYiSG0QaBP2vX2ckzl"},"toc":true,"fancybox":true,"pjax":true};
</script>

    <title> CANAL源码解析-binlog消费位点的控制 - Anthon </title>
  <meta name="generator" content="Hexo 4.2.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="mobile-header-logo">
    <a href="/." class="logo">Anthon</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Anthon</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          CANAL源码解析-binlog消费位点的控制
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-02-07
        </span>
        
        
        <span class="post-visits"
             data-url="/2020/02/07/CANAL%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-binlog%E6%B6%88%E8%B4%B9%E4%BD%8D%E7%82%B9%E7%9A%84%E6%8E%A7%E5%88%B6/"
             data-title="CANAL源码解析-binlog消费位点的控制">
          阅读次数 0
        </span>
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#CanalMQStarter-work"><span class="toc-text">CanalMQStarter.work</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CanalMetaManager"><span class="toc-text">CanalMetaManager</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MemoryMetaManager"><span class="toc-text">MemoryMetaManager</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#subscribe相关的方法"><span class="toc-text">subscribe相关的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cursor相关的方法"><span class="toc-text">cursor相关的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#batch相关的方法"><span class="toc-text">batch相关的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PeriodMixedMetaManager"><span class="toc-text">PeriodMixedMetaManager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileMixedMetaManager"><span class="toc-text">FileMixedMetaManager</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol>
    </div>
  </div>



    <div class="post-content">
      
        <p>canal是一个订阅消费模式的服务，于是其消费位点的控制就非常重要，在正常情况或者重启canal之后都要保证不重复消费同一个位点，也不能漏掉某一个位点。本文我们来看看canal是如何控制消费位点的。</p>
<p>首先我们来分析客户端是如何工作，前文我们分析过CanalMQStarter的启动过程会为每个destination都新建一个CanalMQRunnable，在不同的线程中来执行CanalMQRunnable。CanalMQRunnable的执行调用CanalMQStarter的worker方法。数据的消费与传输都在这个worker方法中执行。</p>
<h2 id="CanalMQStarter-work"><a href="#CanalMQStarter-work" class="headerlink" title="CanalMQStarter.work"></a>CanalMQStarter.work</h2><p>首先是一个准备过程：</p>
<ol>
<li>新建ClientIdentity，作为client的标识</li>
<li>从canalServer（<code>CanalServerWithEmbedded</code>）中获取instance</li>
<li>新建<code>CanalDestination</code>，这个类保存了mq的配置信息</li>
<li>调用<code>canalServer.subscribe</code>向<code>CanalServerWithEmbedded</code>中注册client的信息<br> a. 调用checkStart确保destination对应的instance已经启动<br> b. 获取instance中保存的<code>CanalMetaManager</code>，<code>CanalMetaManager</code>是meta信息的管理器，其中保存着关键的position信息<br> c. 判断<code>CanalMetaManager</code>是否已经启动，如果没有启动则调用start()方法启动<code>CanalMetaManager</code>。正常情况下<code>CanalMetaManager</code>在instance启动时已经被启动了<br> d. 调用<code>CanalMetaManager</code>的subscribe方法在<code>CanalMetaManager</code>中增加订阅信息<br> e. 调用<code>CanalMetaManager</code>的getCursor方法获取当前订阅binlog的位置信息<br> f. 如果position为null，说明之前没有记录position信息：<pre><code> - 从`CanalEventStore`中获取保存的第一条数据的position信息
 - 如果`CanalEventStore`中保存的position信息不为null，调用`CanalMetaManager`的`updateCursor`方法更新`CanalMetaManager`中保存的position信息
</code></pre> g. 调用<code>CanalInstance</code>的subscribeChange方法，通知CanalInstance订阅关系变化<pre><code> - 如果identity中设置的filter过滤条件不为空，则将其设置到eventParser中
</code></pre></li>
</ol>
<p>前面的准备过程基本就是一个向CanalMetaManager注册客户端并处理消费位点的工作。</p>
<a id="more"></a>
<p>接下来是循环读取数据的过程：</p>
<ol>
<li>调用<code>CanalServerWithEmbedded</code>的getWithoutAck方法获取binlog消息。<br><code>getWithoutAck</code>方法一次获取一批（batch）的binlog，canal会为这批binlog生成一个唯一的batchId。客户端如果消费成功，则调用ack方法对这个批次的数据进行确认。如果失败的话，可以调用rollback方法进行回滚。客户端可以连续多次调用getWithoutAck方法来获取binlog，在ack的时候，需要按照获取到binlog的先后顺序进行ack。如果后面获取的binlog被ack了，那么之前没有ack的binlog消息也会自动被ack。</li>
</ol>
<p>注意getWithoutAck方法中有一个synchronized (canalInstance)代码，即虽然destination可以对应多个客户端，但是每个客户端不能并发获取binlog消息。</p>
<pre><code>1. 从`CanalEventStore`中读取数据，保存在events中：
    a. 如果`PositionRange`不为null，从CanalEventStore中获取PositionRange开始位置之后的数据
    b. 如果`PositionRange`为null，说明是ack后第一次获取数据：
        - 调用`CanalMetaManager`的getCursor(ClientIdentity clientIdentity)方法获取cursor游标start。如果start为null，调用`CanalEventStore`的getFirstPosition方法获取CanalEventStore中保存的第一条数据
        - 从`CanalEventStore`中获取start之后的数据
    c. 将events包装成Message返回：
        - 如果events为空，返回空的Message，batchId设置为-1。
        - 果events不为空，调用`CanalMetaManager`的`addBatch`方法记录`PositionRange`，返回一个唯一的batchId。将events做相应转换之后包装成Message返回。
根据位置从`CanalEventStore`中获取binlog数据，为了尽量提高效率，一般一次获取一批binlog，而不是获取一条。这个批次的大小（batchSize）由客户端指定。同时客户端可以指定超时时间，在超时时间内，如果获取到了batchSize的binlog，会立即返回。如果超时了还没有获取到batchSize指定的binlog个数，也会立即返回。特别的，如果没有设置超时时间，没有获取到binlog也会立即返回。

在`CanalMetaManager`中记录这个批次的binlog消息。`CanalMetaManager`会为获取到的这个批次的binlog生成一个唯一的batchId。batchId是递增的，如果binlog信息为空，则直接把batchId设置为-1。
</code></pre><ol>
<li><p>如果message不为空，将数据发送到mq中</p>
<ol>
<li><p>如果发送成功，调用CanalServerWithEmbedded的ack方法确认小于batchId的消息已经被消费。<br> a. 调用<code>CanalMetaManager</code>的removeBatch删除batchId表示的PositionRange数据<br> b. 调用<code>CanalMetaManager</code>的updateCursor方法更新cursor<br> c. 调用<code>CanalEventStore</code>的ack方法删除经过确认的数据</p>
</li>
<li><p>如果发送失败，调用CanalServerWithEmbedded的rollback方法回滚batchId表示的数据<br> a. 调用CanalMetaManager的removeBatch删除batchId表示的PositionRange数据<br> b. 调用CanalEventStore的rollback方法回滚到指定的位置</p>
</li>
</ol>
</li>
</ol>
<p>下面我们来分析其中涉及到的细节。</p>
<h2 id="CanalMetaManager"><a href="#CanalMetaManager" class="headerlink" title="CanalMetaManager"></a>CanalMetaManager</h2><p>从前面的分析中，消费位点控制最关键的是CanalMetaManager类。CanalMetaManager主要用于记录客户端获取的未ack的PositionRange日志信息（开始位置、结束位置、ack位置以及对应的batchId），实现重试功能，保证数据传输的可靠性。提供如下功能：</p>
<ul>
<li>订阅行为处理：记录destination和ClientIdentity的对应关系</li>
<li>未ack日志记录行为处理：通过MemoryClientIdentityBatch来实现获取指定batchId、最新或者第一个未ack日志的PositionRange。</li>
<li>添加、获取未ack的日志记录：通过从eventstore中获取指定数量的event的PositionRange后（并不保存数据信息），添加到CanalMetaManager中，并通过唯一batchId进行绑定，支持通过batchId获取未ack日志记录的功能。</li>
<li>删除已经ack日志记录的行为：通过batchId删除已经ack过的日志记录。注意：ack和rollback必须按照分发处理的顺序处理，即只能ack当前最小的batchId。不然容易出现丢数据的问题。</li>
<li>获取、清空所有未处理ack日志：获取和清空MemoryClientIdentityBatch中的记录</li>
<li>更新最近被ack的日志文件位置：从PositionRange中获取应该ack的Position位置，进行更新到cursor游标中</li>
</ul>
<p>下面我们来分析CanalMetaManager类。</p>
<img src="/2020/02/07/CANAL%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-binlog%E6%B6%88%E8%B4%B9%E4%BD%8D%E7%82%B9%E7%9A%84%E6%8E%A7%E5%88%B6/CanalMetaManager_uml.png" class="">
<p>如上图所示，CanalMetaManager是一个接口，其中有5个实现类。canal是如何来选择实现类的呢？前文我们提到过canal的实例是通过Spring来生成的，生成实例配置的时候会指定xml文件，Spring就是通过这个xml文件来生成实例。</p>
<p>默认可以选择以下几种xml文件，后面写上了它选择的CanalMetaManager实现类：</p>
<ul>
<li>spring/default-instance.xml：PeriodMixedMetaManager</li>
<li>spring/file-instance.xml：FileMixedMetaManager</li>
<li>spring/group-instance.xml：MemoryMetaManager</li>
<li>spring/memory-instance.xml：MemoryMetaManager</li>
</ul>
<p>可以看到不同的xml配置文件，选择的CanalMetaManager实现类是不同的。其中最为重要的是MemoryMetaManager，其中几个实现类也是基于它实现的。</p>
<p>下面我们来分析MemoryMetaManager类。</p>
<h3 id="MemoryMetaManager"><a href="#MemoryMetaManager" class="headerlink" title="MemoryMetaManager"></a>MemoryMetaManager</h3><p>如名称所示，MemoryMetaManager将日志消费位点信息记录在内存中。</p>
<p>它有3个变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Map&lt;String, List&lt;ClientIdentity&gt;&gt;              destinations;</span><br><span class="line"><span class="keyword">protected</span> Map&lt;ClientIdentity, MemoryClientIdentityBatch&gt; batches;</span><br><span class="line"><span class="keyword">protected</span> Map&lt;ClientIdentity, Position&gt;                  cursors;</span><br></pre></td></tr></table></figure>
<ul>
<li>destinations中保存的是每个destination对应的客户端（从中可以看出针对一个destination可以启动多个客户端）</li>
<li>batches中保存的是客户端消费的log位置范围</li>
<li>cursors中保存的是客户端应答后的log位置</li>
</ul>
<p>下面说明一下其中涉及的类：</p>
<ul>
<li><p><code>ClientIdentity</code>：</p>
<p>客户端的标识。其中保存着以下3个字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String            destination;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">short</span>             clientId;</span><br><span class="line"><span class="keyword">private</span> String            filter;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">`clientId`默认为`1001`</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">- `MemoryClientIdentityBatch`：</span><br><span class="line"></span><br><span class="line">客户端消费的批量数据。其中保存着以下3个字段：</span><br><span class="line">```java</span><br><span class="line">private ClientIdentity           clientIdentity;</span><br><span class="line">private Map&lt;Long, PositionRange&gt; batches          = new MapMaker().makeMap();</span><br><span class="line">private AtomicLong               atomicMaxBatchId = new AtomicLong(1);</span><br></pre></td></tr></table></figure>
<p><code>batches</code>中保存着batchId和<code>PositionRange</code>的对应关系。<code>PositionRange</code>中保存日志的开始位置、结束位置和ack位置。</p>
<p><code>atomicMaxBatchId</code>记录最大的batchId。</p>
<ul>
<li><code>Position</code>：</li>
</ul>
<p>Position是一个抽象类，其实现类LogPosition用于标识数据库日志位置。</p>
<p>其中保存着一下2个字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> LogIdentity       identity;</span><br><span class="line"><span class="keyword">private</span> EntryPosition     postion;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#96;LogIdentity&#96;是数据库日志标识。保存着canal server的&#96;slaveId&#96;和&#96;sourceAddress&#96;信息</span><br><span class="line"></span><br><span class="line">&#96;EntryPosition&#96;是数据库对象标识。保存着&#96;included&#96;、&#96;journalName&#96;、&#96;position&#96;、&#96;serverId&#96;、&#96;gtid&#96;、&#96;timestamp&#96;信息</span><br></pre></td></tr></table></figure>
<p>下面来分析MemoryMetaManager的几个方法：</p>
<h4 id="subscribe相关的方法"><a href="#subscribe相关的方法" class="headerlink" title="subscribe相关的方法"></a>subscribe相关的方法</h4><p>subscribe相关的方法有如下4个，具体代码略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加一个 client订阅 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * 如果 client已经存在，则不做任何修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ClientIdentity clientIdentity)</span> <span class="keyword">throws</span> CanalMetaManagerException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否订阅</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasSubscribe</span><span class="params">(ClientIdentity clientIdentity)</span> <span class="keyword">throws</span> CanalMetaManagerException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取消client订阅</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(ClientIdentity clientIdentity)</span> <span class="keyword">throws</span> CanalMetaManagerException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定的destination列出当前所有的clientIdentity信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List&lt;ClientIdentity&gt; <span class="title">listAllSubscribeInfo</span><span class="params">(String destination)</span> <span class="keyword">throws</span> CanalMetaManagerException</span>;</span><br></pre></td></tr></table></figure>
<p>主要的功能就是围绕destinations变量，在ClientIdentity列表中增减数据。本质上就是在destinations中记录ClientIdentity数据，来表示客户端正在订阅数据。删除订阅则是删除destinations中的ClientIdentity数据。</p>
<h4 id="cursor相关的方法"><a href="#cursor相关的方法" class="headerlink" title="cursor相关的方法"></a>cursor相关的方法</h4><p>cursor相关的方法有如下2个，具体代码略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 cursor 游标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Position <span class="title">getCursor</span><span class="params">(ClientIdentity clientIdentity)</span> <span class="keyword">throws</span> CanalMetaManagerException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新 cursor 游标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateCursor</span><span class="params">(ClientIdentity clientIdentity, Position position)</span> <span class="keyword">throws</span> CanalMetaManagerException</span>;</span><br></pre></td></tr></table></figure>
<p>cursor相关的方法也是简单地围绕cursors记录ClientIdentity对应的Position信息。</p>
<h4 id="batch相关的方法"><a href="#batch相关的方法" class="headerlink" title="batch相关的方法"></a>batch相关的方法</h4><p>batch相关的方法有如下8个，具体代码略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得该client最新的一个位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">PositionRange <span class="title">getFirstBatch</span><span class="params">(ClientIdentity clientIdentity)</span> <span class="keyword">throws</span> CanalMetaManagerException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得该clientId最新的一个位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">PositionRange <span class="title">getLastestBatch</span><span class="params">(ClientIdentity clientIdentity)</span> <span class="keyword">throws</span> CanalMetaManagerException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为 client 产生一个唯一、递增的id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Long <span class="title">addBatch</span><span class="params">(ClientIdentity clientIdentity, PositionRange positionRange)</span> <span class="keyword">throws</span> CanalMetaManagerException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定batchId，插入batch数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addBatch</span><span class="params">(ClientIdentity clientIdentity, PositionRange positionRange, Long batchId)</span> <span class="keyword">throws</span> CanalMetaManagerException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据唯一messageId，查找对应的数据起始信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">PositionRange <span class="title">getBatch</span><span class="params">(ClientIdentity clientIdentity, Long batchId)</span> <span class="keyword">throws</span> CanalMetaManagerException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对一个batch的确认</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">PositionRange <span class="title">removeBatch</span><span class="params">(ClientIdentity clientIdentity, Long batchId)</span> <span class="keyword">throws</span> CanalMetaManagerException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询当前的所有batch信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Map&lt;Long, PositionRange&gt; <span class="title">listAllBatchs</span><span class="params">(ClientIdentity clientIdentity)</span> <span class="keyword">throws</span> CanalMetaManagerException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清除对应的batch信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearAllBatchs</span><span class="params">(ClientIdentity clientIdentity)</span> <span class="keyword">throws</span> CanalMetaManagerException</span>;</span><br></pre></td></tr></table></figure>
<p>这些方法获取batches中保存的MemoryClientIdentityBatch，调用MemoryClientIdentityBatch类中的相应方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addPositionRange</span><span class="params">(PositionRange positionRange, Long batchId)</span> </span>&#123;</span><br><span class="line">    updateMaxId(batchId);</span><br><span class="line">    batches.put(batchId, positionRange);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Long <span class="title">addPositionRange</span><span class="params">(PositionRange positionRange)</span> </span>&#123;</span><br><span class="line">    Long batchId = atomicMaxBatchId.getAndIncrement();</span><br><span class="line">    batches.put(batchId, positionRange);</span><br><span class="line">    <span class="keyword">return</span> batchId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> PositionRange <span class="title">removePositionRange</span><span class="params">(Long batchId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (batches.containsKey(batchId)) &#123;</span><br><span class="line">        Long minBatchId = Collections.min(batches.keySet());</span><br><span class="line">        <span class="keyword">if</span> (!minBatchId.equals(batchId)) &#123;</span><br><span class="line">            <span class="comment">// 检查一下提交的ack/rollback，必须按batchId分出去的顺序提交，否则容易出现丢数据</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CanalMetaManagerException(String.format(<span class="string">"batchId:%d is not the firstly:%d"</span>,</span><br><span class="line">                batchId,</span><br><span class="line">                minBatchId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> batches.remove(batchId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> PositionRange <span class="title">getPositionRange</span><span class="params">(Long batchId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> batches.get(batchId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> PositionRange <span class="title">getLastestPositionRange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (batches.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Long batchId = Collections.max(batches.keySet());</span><br><span class="line">        <span class="keyword">return</span> batches.get(batchId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> PositionRange <span class="title">getFirstPositionRange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (batches.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Long batchId = Collections.min(batches.keySet());</span><br><span class="line">        <span class="keyword">return</span> batches.get(batchId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Map&lt;Long, PositionRange&gt; <span class="title">listAllPositionRange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;Long&gt; batchIdSets = batches.keySet();</span><br><span class="line">    List&lt;Long&gt; batchIds = Lists.newArrayList(batchIdSets);</span><br><span class="line">    Collections.sort(Lists.newArrayList(batchIds));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Maps.newHashMap(batches);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clearPositionRanges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    batches.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">updateMaxId</span><span class="params">(Long batchId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (atomicMaxBatchId.get() &lt; batchId + <span class="number">1</span>) &#123;</span><br><span class="line">        atomicMaxBatchId.set(batchId + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>MemoryClientIdentityBatch</code>中方法就是围绕着batches变量对<code>PositionRange</code>进行增删改查。</p>
<h3 id="PeriodMixedMetaManager"><a href="#PeriodMixedMetaManager" class="headerlink" title="PeriodMixedMetaManager"></a>PeriodMixedMetaManager</h3><p>我们再来看看PeriodMixedMetaManager，它是default-instance.xml中定义的CanalMetaManager实现。</p>
<p>它和MemoryMetaManager的主要区别就是增加了一个定时任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">updateCursorTasks = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;ClientIdentity&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动定时工作任务</span></span><br><span class="line">executor.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;ClientIdentity&gt; tasks = <span class="keyword">new</span> ArrayList&lt;ClientIdentity&gt;(updateCursorTasks);</span><br><span class="line">        <span class="keyword">for</span> (ClientIdentity clientIdentity : tasks) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 定时将内存中的最新值刷到zookeeper中，多次变更只刷一次</span></span><br><span class="line">                zooKeeperMetaManager.updateCursor(clientIdentity, getCursor(clientIdentity));</span><br><span class="line">                updateCursorTasks.remove(clientIdentity);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="comment">// ignore</span></span><br><span class="line">                logger.error(<span class="string">"period update"</span> + clientIdentity.toString() + <span class="string">" curosr failed!"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, period, period, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>
<p>该定时任务的主要功能就是获取内存中保存的cursor数据，将其保存到zookeeper中。当canal重启之后能获得之前已经处理过的cursor数据，canal就可以从这个位置接下去获取新的数据。</p>
<p>更新cursor的操作在updateCursor方法中触发：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCursor</span><span class="params">(ClientIdentity clientIdentity, Position position)</span> <span class="keyword">throws</span> CanalMetaManagerException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.updateCursor(clientIdentity, position);</span><br><span class="line">    updateCursorTasks.add(clientIdentity);<span class="comment">// 添加到任务队列中进行触发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FileMixedMetaManager"><a href="#FileMixedMetaManager" class="headerlink" title="FileMixedMetaManager"></a>FileMixedMetaManager</h3><p>再来看看FileMixedMetaManager，它是file-instance.xml中定义的CanalMetaManager实现。</p>
<p>它和PeriodMixedMetaManager的主要区别就是PeriodMixedMetaManager是将cursor数据写到zookeeper，而FileMixedMetaManager是将cursor数据写到文件中，文件名为meta.dat。这种机制主要适合单机部署canal的时候使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">updateCursorTasks = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;ClientIdentity&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动定时工作任务</span></span><br><span class="line">executor.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;ClientIdentity&gt; tasks = <span class="keyword">new</span> ArrayList&lt;ClientIdentity&gt;(updateCursorTasks);</span><br><span class="line">        <span class="keyword">for</span> (ClientIdentity clientIdentity : tasks) &#123;</span><br><span class="line">            MDC.put(<span class="string">"destination"</span>, String.valueOf(clientIdentity.getDestination()));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 定时将内存中的最新值刷到file中，多次变更只刷一次</span></span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    LogPosition cursor = (LogPosition) getCursor(clientIdentity);</span><br><span class="line">                    logger.info(<span class="string">"clientId:&#123;&#125; cursor:[&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;] address[&#123;&#125;]"</span>, <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">                            clientIdentity.getClientId(), cursor.getPostion().getJournalName(),</span><br><span class="line">                            cursor.getPostion().getPosition(), cursor.getPostion().getTimestamp(),</span><br><span class="line">                            cursor.getPostion().getServerId(), cursor.getPostion().getGtid(),</span><br><span class="line">                            cursor.getIdentity().getSourceAddress().toString() &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                flushDataToFile(clientIdentity.getDestination());</span><br><span class="line">                updateCursorTasks.remove(clientIdentity);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="comment">// ignore</span></span><br><span class="line">                logger.error(<span class="string">"period update"</span> + clientIdentity.toString() + <span class="string">" curosr failed!"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">    period,</span><br><span class="line">    period,</span><br><span class="line">    TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>canal在CanalMetaManager中管理binlog消费位点。它的消费流程可以总结为以下几个步骤：</p>
<ol>
<li>获取读取binlog的开始位置。这个开始位置依次从3个地方获取：最近的batch数据、cursor游标、CanalEventStore中保存的第一条数据</li>
<li>从CanalEventStore中获取这个上面开始位置之后的一批binlog数据，保存到CanalMetaManager的batch中，返回一个唯一的batchId</li>
<li>数据消费成功后，调用ack方法确认batchId表示的一批数据。否则调用rollback回滚batchId表示的数据</li>
</ol>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="http://code-monkey.top">Anthon</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="http://code-monkey.top/2020/02/07/CANAL%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-binlog%E6%B6%88%E8%B4%B9%E4%BD%8D%E7%82%B9%E7%9A%84%E6%8E%A7%E5%88%B6/">http://code-monkey.top/2020/02/07/CANAL%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-binlog%E6%B6%88%E8%B4%B9%E4%BD%8D%E7%82%B9%E7%9A%84%E6%8E%A7%E5%88%B6/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/canal/">canal</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2020/02/07/CANAL%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-monitor%E6%9C%BA%E5%88%B6/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">CANAL源码解析-monitor机制</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2020/02/07/CANAL%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-driver%E6%A8%A1%E5%9D%97/">
        <span class="next-text nav-default">CANAL源码解析-driver模块</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:tanghuaidong@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/tangboy" target="_blank" rel="noopener" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
        
          <a href="https://www.zhihu.com/people/tang-huai-dong/activities" target="_blank" rel="noopener" class="iconfont icon-zhihu" title="zhihu"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    
      
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2020

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Anthon</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  

  



    
  



  
  





  
    <script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

  
    <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.10.1"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

  </body>
</html>
