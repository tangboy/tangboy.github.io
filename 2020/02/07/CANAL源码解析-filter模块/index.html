<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta name="generator" content="Hexo 3.8.0">
    
<!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="CANAL源码解析-filter模块">




  <meta name="keywords" content="canal, Anthon">










  <link rel="alternate" href="/default" title="Anthon">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.10.1">



<link rel="canonical" href="http://code-monkey.top/2020/02/07/CANAL源码解析-filter模块/">



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">




  <link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css">



<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.10.1">



  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":true};
</script>

    <title> CANAL源码解析-filter模块 - Anthon </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="mobile-header-logo">
    <a href="/." class="logo">Anthon</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Anthon</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          CANAL源码解析-filter模块
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-02-07
        </span>
        
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Filter简介"><span class="toc-text">Filter简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#服务端配置"><span class="toc-text">服务端配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#客户端配置"><span class="toc-text">客户端配置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Aviator快速入门"><span class="toc-text">Aviator快速入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#编译表达式"><span class="toc-text">编译表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义函数"><span class="toc-text">自定义函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AviaterRegexFilter源码解析"><span class="toc-text">AviaterRegexFilter源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#filter方法"><span class="toc-text">filter方法</span></a></li></ol></li></ol></li></ol>
    </div>
  </div>



    <div class="post-content">
      
        <h1 id="Filter简介"><a href="#Filter简介" class="headerlink" title="Filter简介"></a>Filter简介</h1><p>filter模块用于对binlog进行过滤。在实际开发中，一个mysql实例中可能会有多个库，每个库里面又会有多个表，可能我们只是想订阅某个库中的部分表，这个时候就需要进行过滤。也就是说，parser模块解析出来binlog之后，会进行一次过滤之后，才会存储到store模块中。</p>
<p>过滤规则的配置既可以在canal服务端进行，也可以在客户端进行。</p>
<h2 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h2><p>我们在配置一个canal instance时，在instance.properties中有以下两个配置项：</p>
<img src="/2020/02/07/CANAL源码解析-filter模块/1.png">
<p>其中：</p>
<ul>
<li>canal.instance.filter.regex用于配置白名单，也就是我们希望订阅哪些库，哪些表，默认值为.<em>\..</em>，也就是订阅所有库，所有表。</li>
<li>canal.instance.filter.black.regex用于配置黑名单，也就是我们不希望订阅哪些库，哪些表。没有默认值，也就是默认黑名单为空。</li>
</ul>
<p>需要注意的是，在过滤的时候，会先根据白名单进行过滤，再根据黑名单过滤。意味着，如果一张表在白名单和黑名单中都出现了，那么这张表最终不会被订阅到，因为白名单通过后，黑名单又将这张表给过滤掉了。</p>
<a id="more"></a>
<p>另外一点值得注意的是，过滤规则使用的是perl正则表达式，而不是jdk自带的正则表达式。意味着filter模块引入了其他依赖，来进行匹配。具体来说，filter模块的pom.xml中包含以下两个依赖： </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.googlecode.aviator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aviator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>oro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>oro<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中： </p>
<ul>
<li><strong>aviator：</strong>是一个开源的、高性能、轻量级的 java 语言实现的表达式求值引擎</li>
<li><strong>oro：</strong> 全称为Jakarta ORO，最全面以及优化得最好的正则表达式API之一，Jakarta-ORO库以前叫做OROMatcher，是由DanielF. Savarese编写，后来捐赠给了apache Jakarta Project。canal的过滤规则就是通过oro中的Perl5Matcher来进行完成的。</li>
</ul>
<p>显然，对于filter模块的源码解析，实际上主要变成了对aviator、oro的分析。</p>
<p>这一点，我们可以从filter模块核心接口CanalEventFilter的实现类中得到验证。CanalEventFilter接口定义了一个filter方法： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CanalEventFilter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(T event)</span> <span class="keyword">throws</span> CanalFilterException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前针对CanalEventFilter提供了3个实现类，都是基于开源的java表达式求值引擎Aviator，如下：</p>
<img src="/2020/02/07/CANAL源码解析-filter模块/2.png">
<p>提示：这个3个实现都是以Aviater开头，应该是拼写错误，正确的应该是Aviator。</p>
<p>其中：</p>
<ul>
<li>AviaterELFilter：基于Aviator el表达式的匹配过滤</li>
<li>AviaterSimpleFilter：基于Aviator进行tableName简单过滤计算，不支持正则匹配</li>
<li>AviaterRegexFilter：基于Aviator进行tableName正则匹配的过滤算法。内部使用到了一个RegexFunction类，这是对Aviator自定义的函数的扩展，内部使用到了oro中的Perl5Matcher来进行正则匹配。 </li>
</ul>
<p>需要注意的是，尽管filter模块提供了3个基于Aviator的过滤器实现，但是实际上使用到的只有AviaterRegexFilter。这一点可以在canal-deploy模块提供的xxx-instance.xml配置文件中得要验证。以default-instance.xml为例，eventParser这个bean包含以下两个属性：</p>
<p>其中：</p>
<ul>
<li>eventFilter属性：使用配置项canal.instance.filter.regex的值进行白名单过滤。</li>
<li>eventBlackFilter属性：使用配置项canal.instance.filter.black.regex进行黑名单过滤。</li>
</ul>
<p>这两个属性的值都是通过一个内部bean的方式进行配置，类型都是AviaterRegexFilter。由于其他两个类型的CanalEventFilter实现在parser模块中并没有使用到，因此后文中，我们也只会对AviaterRegexFilter进行分析。</p>
<p>前面提到，parser模块在过滤的时候，会先根据canal.instance.filter.regex进行白名单过滤，再根据 canal.instance.filter.black.regex进行黑名单过滤。到这里，实际上就是先通过eventFilter进行白名单过滤，通过eventBlackFilter进行黑名单过滤。</p>
<p>parser模块实际上会将eventFilter、eventBlackFilter设置到一个LogEventConvert对象中，这个对象有2个方法：parseQueryEvent和parseRowsEvent都进行了过滤。以parseRowsEvent方法为例：</p>
<p>com.alibaba.otter.canal.parse.inbound.mysql.dbsync.LogEventConvert#parseRowsEvent(省略部分代码片段)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">parseRowsEvent</span><span class="params">(RowsLogEvent event)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">        TableMapLogEvent table = event.getTable();</span><br><span class="line">        String fullname = table.getDbName() + <span class="string">"."</span> + table.getTableName();</span><br><span class="line">        <span class="comment">// check name filter</span></span><br><span class="line">        <span class="keyword">if</span> (nameFilter != <span class="keyword">null</span> &amp;&amp; !nameFilter.filter(fullname)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nameBlackFilter != <span class="keyword">null</span> &amp;&amp; nameBlackFilter.filter(fullname)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的nameFilter、nameBlackFilter实际上就是我们设置到parser中的 eventFilter、eventBlackFilter，只不过parser将其设置到LogEventConvert对象中换了一个名字。</p>
<p>可以看到，的确是先使用nameFilter进行白名单过滤，再使用nameBlackFilter进行黑名单过滤。在过滤时，使用dbName+”.”+tableName作为参数，进行过滤。如果被过滤掉了，就返回null。</p>
<p>再次提醒，由于黑名单后过滤，因此如果希望订阅一个表，一定不要在黑名单中出现。</p>
<h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>上面提到的都是服务端配置。canal也支持客户端配置过滤规则。举例来说，假设一个库有10张表，一个client希望订阅其中5张表，另一个client希望订阅另5张表。此时，服务端可以订阅10张表，当client来消费的时候，根据client的过滤规则只返回给对应的binlog event。</p>
<p>客户端指定过滤规则通过client模块中的CanalConnector的subscribe方法来进行，subscribe有两种重载形式，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于第一个subscribe方法，不指定filter，以服务端的filter为准</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">()</span> <span class="keyword">throws</span> CanalClientException</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 指定了filter：</span></span><br><span class="line"><span class="comment">// 如果本次订阅中filter信息为空，则直接使用canal server服务端配置的filter信息</span></span><br><span class="line"><span class="comment">// 如果本次订阅中filter信息不为空，目前会直接替换canal server服务端配置的filter信息，以本次提交的为准</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(String filter)</span> <span class="keyword">throws</span> CanalClientException</span>;</span><br></pre></td></tr></table></figure>
<p>通过不同client指定不同的过滤规则，可以达到服务端一份数据供多个client进行订阅消费的效果。        </p>
<p>然而，想法是好的，现实确是残酷的，由于目前一个canal instance只允许一个client订阅，因此目前还达不到这种效果。读者明白这种设计的初衷即可。</p>
<p>最后列出filter模块的目录结构，这个模块的类相当的少，如下： </p>
<img src="/2020/02/07/CANAL源码解析-filter模块/3.png">
<p>到此，filter模块的主要作用已经讲解完成。接着应该针对AviaterRegexFilter进行源码分析，由于其基于Aviator和oro基础之上编写，因此先对Aviator和oro进行介绍。</p>
<h1 id="Aviator快速入门"><a href="#Aviator快速入门" class="headerlink" title="Aviator快速入门"></a>Aviator快速入门</h1><p>说明，这里关于Aviator的相关内容直接摘录自官网：<a href="https://github.com/killme2008/aviator，" target="_blank" rel="noopener">https://github.com/killme2008/aviator，</a> 并没有包含Aviator所有内容，仅仅是就canal内部使用到的一些特性进行讲解。</p>
<p>Aviator是一个高性能、轻量级的 java 语言实现的表达式求值引擎, 主要用于各种表达式的动态求值。现在已经有很多开源可用的 java 表达式求值引擎,为什么还需要 Avaitor 呢?</p>
<p>Aviator的设计目标是轻量级和高性能,相比于Groovy、JRuby的笨重, Aviator非常小, 加上依赖包也才 537K,不算依赖包的话只有 70K; 当然, Aviator的语法是受限的, 它不是一门完整的语言, 而只是语言的一小部分集合。</p>
<p>其次, Aviator的实现思路与其他轻量级的求值器很不相同, 其他求值器一般都是通过解释的方式运行, 而Aviator则是直接将表达式编译成 JVM 字节码, 交给 JVM 去执行。简单来说, Aviator的定位是介于 Groovy 这样的重量级脚本语言和 IKExpression 这样的轻量级表达式引擎之间。</p>
<p>Aviator 的特性：</p>
<ul>
<li>支持绝大多数运算操作符，包括算术操作符、关系运算符、逻辑操作符、位运算符、正则匹配操作符(=~)、三元表达式(?:)</li>
<li>支持操作符优先级和括号强制设定优先级</li>
<li>逻辑运算符支持短路运算。</li>
<li>支持丰富类型，例如nil、整数和浮点数、字符串、正则表达式、日期、变量等，支持自动类型转换。</li>
<li>内置一套强大的常用函数库</li>
<li>可自定义函数，易于扩展</li>
<li>可重载操作符</li>
<li>支持大数运算(BigInteger)和高精度运算(BigDecimal)</li>
<li>性能优秀</li>
</ul>
<p>引入Aviator, 从 3.2.0 版本开始， Aviator 仅支持 JDK 7 及其以上版本。 JDK 6 请使用 3.1.1 这个稳定版本。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.googlecode.aviator&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;aviator&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;&#123;version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>Aviator的使用都是集中通过com.googlecode.aviator.AviatorEvaluator这个入口类来处理。在canal提供的AviaterRegexFilter中，仅仅使用到了Aviator部分功能，我们这里也仅仅就这些功能进行讲解。</p>
<h2 id="编译表达式"><a href="#编译表达式" class="headerlink" title="编译表达式"></a>编译表达式</h2><p><a href="https://github.com/killme2008/aviator/wiki#编译表达式" target="_blank" rel="noopener">参考</a></p>
<p>案例： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAviator</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//1、定义一个字符串表达式</span></span><br><span class="line">            String expression = <span class="string">"a-(b-c)&gt;100"</span>;</span><br><span class="line">            <span class="comment">//2、对表达式进行编译，得到Expression对象实例</span></span><br><span class="line">            Expression compiledExp = AviatorEvaluator.compile(expression);</span><br><span class="line">            <span class="comment">//3、准备计算表达式需要的参数</span></span><br><span class="line">            Map&lt;String, Object&gt; env = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">            env.put(<span class="string">"a"</span>, <span class="number">100.3</span>);</span><br><span class="line">            env.put(<span class="string">"b"</span>, <span class="number">45</span>);</span><br><span class="line">            env.put(<span class="string">"c"</span>, -<span class="number">199.100</span>);</span><br><span class="line">            <span class="comment">//4、执行表达式，通过调用Expression的execute方法</span></span><br><span class="line">            Boolean result = (Boolean) compiledExp.execute(env);</span><br><span class="line">            System.out.println(result);  <span class="comment">// false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过compile方法可以将表达式编译成Expression的中间对象, 当要执行表达式的时候传入env并调用Expression的execute方法即可。 表达式中使用了括号来强制优先级, 这个例子还使用了&gt;用于比较数值大小, 比较运算符!=、==、&gt;、&gt;=、&lt;、&lt;=不仅可以用于数值, 也可以用于String、Pattern、Boolean等等, 甚至是任何用户传入的两个都实现了java.lang.Comparable接口的对象之间。</p>
<p>编译后的结果你可以自己缓存, 也可以交给 Aviator 帮你缓存, AviatorEvaluator内部有一个全局的缓存池, 如果你决定缓存编译结果, 可以通过:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Expression <span class="title">compile</span><span class="params">(String expression, <span class="keyword">boolean</span> cached)</span></span></span><br></pre></td></tr></table></figure></p>
<p>将cached设置为true即可, 那么下次编译同一个表达式的时候将直接返回上一次编译的结果。</p>
<p>使缓存失效通过以下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invalidateCache</span><span class="params">(String expression)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p><a href="https://github.com/killme2008/aviator/wiki#自定义函数" target="_blank" rel="noopener">参考</a></p>
<p>Aviator 除了内置的函数之外,还允许用户自定义函数,只要实现com.googlecode.aviator.runtime.type.AviatorFunction接口, 并注册到AviatorEvaluator即可使用. AviatorFunction接口十分庞大, 通常来说你并不需要实现所有的方法, 只要根据你的方法的参 数个数, 继承AbstractFunction类并override相应方法即可。</p>
<p>可以看一个例子,我们实现一个add函数来做数值的相加:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、自定义函数AddFunction，继承AbstractFunction，覆盖其getName方法和call方法</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AddFunction</span> <span class="keyword">extends</span> <span class="title">AbstractFunction</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 1.1 getName用于返回函数的名字，之后需要使用这个函数时，达表示需要以add开头</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"add"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1.2 在执行计算时，call方法将会被回调。call方法有多种重载形式，参数可以分为2类：</span></span><br><span class="line">        <span class="comment">// 第一类：所有的call方法的第一个参数都是Map类型的env参数。</span></span><br><span class="line">        <span class="comment">// 第二类：不同数量的AviatorObject参数。由于在这里我们的add方法只接受2个参数，</span></span><br><span class="line">        <span class="comment">// 所以覆盖接受2个AviatorObject参数call方法重载形式</span></span><br><span class="line">        <span class="comment">// 用户在执行时，通过"函数名(参数1,参数2,...)"方式执行函数，如："add(1, 2)"</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> AviatorObject <span class="title">call</span><span class="params">(Map&lt;String, Object&gt; env, AviatorObject arg1, AviatorObject arg2)</span> </span>&#123;</span><br><span class="line">            Number left = FunctionUtils.getNumberValue(arg1, env);</span><br><span class="line">            Number right = FunctionUtils.getNumberValue(arg2, env);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AviatorDouble(left.doubleValue() + right.doubleValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAviator</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//注册函数</span></span><br><span class="line">            AviatorEvaluator.addFunction(<span class="keyword">new</span> AddFunction());</span><br><span class="line">            System.out.println(AviatorEvaluator.execute(<span class="string">"add(1, 2)"</span>));           <span class="comment">// 3.0</span></span><br><span class="line">            System.out.println(AviatorEvaluator.execute(<span class="string">"add(add(1, 2), 100)"</span>)); <span class="comment">// 103.0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注册函数通过AviatorEvaluator.addFunction方法, 移除可以通过removeFunction。另外， FunctionUtils 提供了一些方便参数类型转换的方法。</p>
<h2 id="AviaterRegexFilter源码解析"><a href="#AviaterRegexFilter源码解析" class="headerlink" title="AviaterRegexFilter源码解析"></a>AviaterRegexFilter源码解析</h2><p>AviaterRegexFilter实现了CanalEventParser接口，主要是实现其filter方法对binlog进行过滤。</p>
<p>首先对AviaterRegexFilter中定义的字段和构造方法进行介绍：</p>
<p>com.alibaba.otter.canal.filter.aviater.AviaterRegexFilter </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AviaterRegexFilter</span> <span class="keyword">implements</span> <span class="title">CanalEventFilter</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//我们的配置的binlog过滤规则可以由多个正则表达式组成，使用逗号”,"进行分割</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPLIT = <span class="string">","</span>;</span><br><span class="line">    <span class="comment">//将经过逗号",”分割后的过滤规则重新使用|串联起来</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATTERN_SPLIT = <span class="string">"|"</span>;</span><br><span class="line">    <span class="comment">//canal定义的Aviator过滤表达式，使用了regex自定义函数，接受pattern和target两个参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FILTER_EXPRESSION = <span class="string">"regex(pattern,target)"</span>;</span><br><span class="line">    <span class="comment">//regex自定义函数实现，RegexFunction的getName方法返回regex，call方法接受两个参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RegexFunction regexFunction = <span class="keyword">new</span> RegexFunction();</span><br><span class="line">    <span class="comment">//对自定义表达式进行编译，得到Expression对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Expression exp = AviatorEvaluator.compile(FILTER_EXPRESSION, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//将自定义函数添加到AviatorEvaluator中 </span></span><br><span class="line">        AviatorEvaluator.addFunction(regexFunction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用于比较两个字符串的大小  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;String&gt; COMPARATOR = <span class="keyword">new</span> StringComparator();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用户设置的过滤规则，需要使用SPLIT进行分割</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> String pattern;</span><br><span class="line">    <span class="comment">//在没有指定过滤规则pattern情况下的默认值，例如默认为true，表示用户不指定过滤规则情况下，总是返回所有的binlog event</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">boolean</span> defaultEmptyValue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AviaterRegexFilter</span><span class="params">(String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(pattern, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AviaterRegexFilter</span><span class="params">(String pattern, <span class="keyword">boolean</span> defaultEmptyValue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1 给defaultEmptyValue字段赋值</span></span><br><span class="line">        <span class="keyword">this</span>.defaultEmptyValue = defaultEmptyValue;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//2、给pattern字段赋值</span></span><br><span class="line">        <span class="comment">//2.1 将传入pattern以逗号",”进行分割，放到list中；如果没有指定pattern，则list为空，意味着不需要过滤</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(pattern)) &#123;</span><br><span class="line">            list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String[] ss = StringUtils.split(pattern, SPLIT);</span><br><span class="line">            list = Arrays.asList(ss);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.2 对list中的pattern元素，按照从长到短的排序</span></span><br><span class="line">        Collections.sort(list, COMPARATOR);</span><br><span class="line">        </span><br><span class="line">       <span class="comment">//2.3 对pattern进行头尾完全匹配</span></span><br><span class="line">        list = completionPattern(list);</span><br><span class="line">        <span class="comment">//2.4 将过滤规则重新使用|串联起来赋值给pattern</span></span><br><span class="line">        <span class="keyword">this</span>.pattern = StringUtils.join(list, PATTERN_SPLIT);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，2.2 步骤使用了COMPARATOR对list中分割后的pattern进行比较，COMPARATOR的类型是StringComparator，这是定义在AviaterRegexFilter中的一个静态内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 修复正则表达式匹配的问题，因为使用了 oro 的 matches，会出现：</span></span><br><span class="line"><span class="comment">* foo|foot 匹配 foot 出错，原因是 foot 匹配了 foo 之后，会返回 foo，但是 foo 的长度和 foot 的长度不一样</span></span><br><span class="line"><span class="comment">* 因此此类对正则表达式进行了从长到短的排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StringComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (str1.length() &gt; str2.length()) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str1.length() &lt; str2.length()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码2.3节调用completionPattern(list)方法对list中分割后的pattern进行头尾完全匹配</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修复正则表达式匹配的问题，即使按照长度递减排序，还是会出现以下问题：</span></span><br><span class="line"><span class="comment">     *  foooo|f.*t 匹配 fooooot 出错，原因是 fooooot 匹配了 foooo 之后，会将 fooo 和数据进行匹配，</span></span><br><span class="line"><span class="comment">     * 但是 foooo 的长度和 fooooot 的长度不一样，因此此类对正则表达式进行头尾完全匹配</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">completionPattern</span><span class="params">(List&lt;String&gt; patterns)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String pattern : patterns) &#123;</span><br><span class="line">            StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            stringBuffer.append(<span class="string">"^"</span>);</span><br><span class="line">            stringBuffer.append(pattern);</span><br><span class="line">            stringBuffer.append(<span class="string">"$"</span>);</span><br><span class="line">            result.add(stringBuffer.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="filter方法"><a href="#filter方法" class="headerlink" title="filter方法"></a>filter方法</h3><p>AviaterRegexFilter类中最重要的就是filter方法，由这个方法执行过滤，如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1 参数：前面已经分析过parser模块的LogEventConvert中，会将binlog event的 dbName+”."+tableName当做参数过滤</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(String filtered)</span> <span class="keyword">throws</span> CanalFilterException </span>&#123;</span><br><span class="line">        <span class="comment">//2 如果没有指定匹配规则，返回默认值</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(pattern)) &#123;</span><br><span class="line">            <span class="keyword">return</span> defaultEmptyValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3 如果需要过滤的dbName+”.”+tableName是一个空串，返回默认值</span></span><br><span class="line">        <span class="comment">//提示：一些类型的binlog event，如heartbeat，并不是真正修改数据，这种类型的event是没有库名和表名的</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(filtered)) &#123;</span><br><span class="line">            <span class="keyword">return</span> defaultEmptyValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4 将传入的dbName+”."+tableName通过canal自定义的Aviator扩展函数RegexFunction进行计算</span></span><br><span class="line">        Map&lt;String, Object&gt; env = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        env.put(<span class="string">"pattern"</span>, pattern);</span><br><span class="line">        env.put(<span class="string">"target"</span>, filtered.toLowerCase());</span><br><span class="line">        <span class="keyword">return</span> (Boolean) exp.execute(env);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>第4步通过exp.execute方法进行过滤判断，前面已经看到，exp这个Expression实例是通过”regex(pattern,target)”编译得到。根据前面对AviatorEvaluator的介绍，其应该调用一个名字为regex的Aviator自定义函数，这个函数接受2个参数。</p>
<p>RegexFunction的实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexFunction</span> <span class="keyword">extends</span> <span class="title">AbstractFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> AviatorObject <span class="title">call</span><span class="params">(Map&lt;String, Object&gt; env, AviatorObject arg1, AviatorObject arg2)</span> </span>&#123;</span><br><span class="line">        String pattern = FunctionUtils.getStringValue(arg1, env);</span><br><span class="line">        String text = FunctionUtils.getStringValue(arg2, env);</span><br><span class="line">        Perl5Matcher matcher = <span class="keyword">new</span> Perl5Matcher();</span><br><span class="line">        <span class="keyword">boolean</span> isMatch = matcher.matches(text, PatternUtils.getPattern(pattern));</span><br><span class="line">        <span class="keyword">return</span> AviatorBoolean.valueOf(isMatch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"regex"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在这个函数里面，实际上是根据配置的过滤规则pattern，以及需要过滤的内容text(即dbName+”.”+tableName)，通过jarkata-oro中Perl5Matcher类进行正则表达式匹配。 </p>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="http://code-monkey.top">Anthon</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="http://code-monkey.top/2020/02/07/CANAL源码解析-filter模块/">http://code-monkey.top/2020/02/07/CANAL源码解析-filter模块/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/canal/">canal</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2020/02/07/CANAL源码解析-driver模块/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">CANAL源码解析-driver模块</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2020/02/06/CANAL源码解析-store模块/">
        <span class="next-text nav-default">CANAL源码解析-store模块</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:tanghuaidong@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/tangboy" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
        
          <a href="https://www.zhihu.com/people/tang-huai-dong/activities" class="iconfont icon-zhihu" title="zhihu"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    
      
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2020

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Anthon</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  

  



    
  



  
  





  
    <script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

  
    <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.10.1"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

  </body>
</html>
