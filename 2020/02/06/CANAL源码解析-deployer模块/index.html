<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta name="generator" content="Hexo 3.8.0">
    
<!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="CANAL源码解析-deployer模块">




  <meta name="keywords" content="canal, Anthon">










  <link rel="alternate" href="/default" title="Anthon">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.10.1">



<link rel="canonical" href="http://code-monkey.top/2020/02/06/CANAL源码解析-deployer模块/">



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">




  <link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css">



<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.10.1">



  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":true};
</script>

    <title> CANAL源码解析-deployer模块 - Anthon </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="mobile-header-logo">
    <a href="/." class="logo">Anthon</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Anthon</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          CANAL源码解析-deployer模块
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-02-06
        </span>
        
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#启动和停止脚本"><span class="toc-text">启动和停止脚本</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CannalLauncher"><span class="toc-text">CannalLauncher</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CanalController"><span class="toc-text">CanalController</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#配置解析相关代码"><span class="toc-text">配置解析相关代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#globalInstanceConfig字段"><span class="toc-text">globalInstanceConfig字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceGenerator字段"><span class="toc-text">instanceGenerator字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceConfigs字段"><span class="toc-text">instanceConfigs字段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#准备canal-server相关代码"><span class="toc-text">准备canal server相关代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CanalInstance运行状态监控相关代码"><span class="toc-text">CanalInstance运行状态监控相关代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#autoScan机制相关代码"><span class="toc-text">autoScan机制相关代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CanalController的start方法"><span class="toc-text">CanalController的start方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol>
    </div>
  </div>



    <div class="post-content">
      
        <p>canal有两种使用方式：1、独立部署 2、内嵌到应用中。 deployer模块主要用于独立部署canal server。关于这两种方式的区别，请参见server模块源码分析。deployer模块源码目录结构如下所示：</p>
<img src="/2020/02/06/CANAL源码解析-deployer模块/1.png">
<p>在独立部署canal时，需要首先对canal的源码进行打包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install -Dmaven.test.skip -Denv=release</span><br></pre></td></tr></table></figure>
<p>打包后会在target目录生成一个以下两个文件：<br><img src="/2020/02/06/CANAL源码解析-deployer模块/2.png"></p>
<p>其中canal.deployer-1.0.24.tar.gz就是canal的独立部署包。解压缩后，目录如下所示。其中bin目录和conf目录(包括子目录spring)中的所有文件，都来自于deployer模块。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">canal</span><br><span class="line">├── bin</span><br><span class="line">│   ├── startup.bat</span><br><span class="line">│   ├── startup.sh</span><br><span class="line">│   └── stop.sh</span><br><span class="line">├── conf</span><br><span class="line">│   ├── canal.properties</span><br><span class="line">│   ├── example</span><br><span class="line">│   │   └── instance.properties</span><br><span class="line">│   ├── logback.xml</span><br><span class="line">│   └── spring</span><br><span class="line">│       ├── default-instance.xml</span><br><span class="line">│       ├── file-instance.xml</span><br><span class="line">│       ├── group-instance.xml</span><br><span class="line">│       ├── <span class="built_in">local</span>-instance.xml</span><br><span class="line">│       └── memory-instance.xml</span><br><span class="line">├── lib</span><br><span class="line">│   └── ....依赖的各种jar</span><br><span class="line">└── logs</span><br></pre></td></tr></table></figure>
<p>deployer模块主要完成以下功能：</p>
<ol>
<li>读取canal.properties配置文件</li>
<li>启动canal server，监听canal client的请求</li>
<li>启动canal instance，连接mysql数据库，伪装成slave，解析binlog</li>
<li>在canal的运行过程中，监听配置文件的变化</li>
</ol>
<a id="more"></a>
<h1 id="启动和停止脚本"><a href="#启动和停止脚本" class="headerlink" title="启动和停止脚本"></a>启动和停止脚本</h1><p>bin目录中包含了canal的启动和停止脚本startup.sh和stop.sh，当我们要启动canal时，只需要输入以下命令即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh bin/startup.sh</span><br></pre></td></tr></table></figure>
<p>在windows环境下，可以直接双击startup.bat。</p>
<p>在startup.sh脚本内，会调用com.alibaba.otter.canal.deployer.CanalLauncher类来进行启动，这是分析Canal源码的入口类，如下图所示：</p>
<img src="/2020/02/06/CANAL源码解析-deployer模块/3.png">
<p>同时，startup.sh还会在bin目录下生成一个<code>canal.pid</code>文件，用于存储canal的进程id。当停止canal的时候</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh bin/stop.sh</span><br></pre></td></tr></table></figure>
<h1 id="CannalLauncher"><a href="#CannalLauncher" class="headerlink" title="CannalLauncher"></a>CannalLauncher</h1><p><code>CanalLauncher</code>是整个源码分析的入口类，代码相当简单。步骤是：</p>
<ol>
<li>读取canal.properties文件中的配置</li>
<li>利用读取的配置构造一个CanalController实例，将所有的启动操作都委派给CanalController进行处理。</li>
<li>最后注册一个钩子函数，在JVM停止时同时也停止canal server。</li>
</ol>
<p>com.alibaba.otter.canal.deployer.CanalLauncher</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanalLauncher</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLASSPATH_URL_PREFIX = <span class="string">"classpath:"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger               = LoggerFactory.getLogger(CanalLauncher.class);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1、读取canal.properties文件中配置，默认读取classpath下的canal.properties</span></span><br><span class="line">            String conf = System.getProperty(<span class="string">"canal.conf"</span>, <span class="string">"classpath:canal.properties"</span>);</span><br><span class="line">            Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            <span class="keyword">if</span> (conf.startsWith(CLASSPATH_URL_PREFIX)) &#123;</span><br><span class="line">                conf = StringUtils.substringAfter(conf, CLASSPATH_URL_PREFIX);</span><br><span class="line">                properties.load(CanalLauncher.class.getClassLoader().getResourceAsStream(conf));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                properties.load(<span class="keyword">new</span> FileInputStream(conf));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2、启动canal，首先将properties对象传递给CanalController，然后调用其start方法启动</span></span><br><span class="line">            logger.info(<span class="string">"## start the canal server."</span>);</span><br><span class="line">            <span class="keyword">final</span> CanalController controller = <span class="keyword">new</span> CanalController(properties);</span><br><span class="line">            controller.start();</span><br><span class="line">            logger.info(<span class="string">"## the canal server is running now ......"</span>);</span><br><span class="line">            <span class="comment">//3、关闭canal，通过添加JVM的钩子，JVM停止前会回调run方法，其内部调用controller.stop()方法进行停止</span></span><br><span class="line">            Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line"> </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        logger.info(<span class="string">"## stop the canal server"</span>);</span><br><span class="line">                        controller.stop();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        logger.warn(<span class="string">"##something goes wrong when stopping canal Server:\n&#123;&#125;"</span>,</span><br><span class="line">                            ExceptionUtils.getFullStackTrace(e));</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        logger.info(<span class="string">"## canal server is down."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.error(<span class="string">"## Something goes wrong when starting up the canal Server:\n&#123;&#125;"</span>,</span><br><span class="line">                ExceptionUtils.getFullStackTrace(e));</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，CanalLauncher实际上只是负责读取canal.properties配置文件，然后构造CanalController对象，并通过其start和stop方法来开启和停止canal。因此，如果说CanalLauncher是canal源码分析的入口类，那么CanalController就是canal源码分析的核心类。</p>
<h1 id="CanalController"><a href="#CanalController" class="headerlink" title="CanalController"></a>CanalController</h1><p>在CanalController的构造方法中，会对配置文件内容解析，初始化相关成员变量，做好canal server的启动前的准备工作，之后在CanalLauncher中调用CanalController.start方法来启动。</p>
<p>CanalController中定义的相关字段和构造方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanalController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger  logger   = LoggerFactory.getLogger(CanalController.class);</span><br><span class="line">    <span class="keyword">private</span> Long                                     cid;</span><br><span class="line">    <span class="keyword">private</span> String                                   ip; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>                                  port;</span><br><span class="line">    <span class="comment">// 默认使用spring的方式载入    </span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, InstanceConfig&gt;              instanceConfigs;</span><br><span class="line">    <span class="keyword">private</span> InstanceConfig                           globalInstanceConfig;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, CanalConfigClient&gt;           managerClients;</span><br><span class="line">    <span class="comment">// 监听instance config的变化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>                             autoScan = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> InstanceAction                           defaultAction;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;InstanceMode, InstanceConfigMonitor&gt; instanceConfigMonitors;</span><br><span class="line">    <span class="keyword">private</span> CanalServerWithEmbedded                  embededCanalServer;</span><br><span class="line">    <span class="keyword">private</span> CanalServerWithNetty                     canalServer;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> CanalInstanceGenerator                   instanceGenerator;</span><br><span class="line">    <span class="keyword">private</span> ZkClientx                                zkclientx;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CanalController</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(System.getProperties());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CanalController</span><span class="params">(<span class="keyword">final</span> Properties properties)</span></span>&#123;</span><br><span class="line">        managerClients = MigrateMap.makeComputingMap(<span class="keyword">new</span> Function&lt;String, CanalConfigClient&gt;() &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="function"><span class="keyword">public</span> CanalConfigClient <span class="title">apply</span><span class="params">(String managerAddress)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> getManagerClient(managerAddress);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">         <span class="comment">//1、配置解析    </span></span><br><span class="line">       globalInstanceConfig = initGlobalConfig(properties);</span><br><span class="line">        instanceConfigs = <span class="keyword">new</span> MapMaker().makeMap();      </span><br><span class="line">       initInstanceConfig(properties);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 2、准备canal server</span></span><br><span class="line">        cid = Long.valueOf(getProperty(properties, CanalConstants.CANAL_ID));</span><br><span class="line">        ip = getProperty(properties, CanalConstants.CANAL_IP);</span><br><span class="line">        port = Integer.valueOf(getProperty(properties, CanalConstants.CANAL_PORT));</span><br><span class="line">        embededCanalServer = CanalServerWithEmbedded.instance();</span><br><span class="line">        embededCanalServer.setCanalInstanceGenerator(instanceGenerator);<span class="comment">// 设置自定义的instanceGenerator       </span></span><br><span class="line">       canalServer = CanalServerWithNetty.instance();</span><br><span class="line">        canalServer.setIp(ip);</span><br><span class="line">        canalServer.setPort(port);</span><br><span class="line">        </span><br><span class="line">         <span class="comment">//3、初始化zk相关代码 </span></span><br><span class="line">        <span class="comment">// 处理下ip为空，默认使用hostIp暴露到zk中       </span></span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isEmpty(ip)) &#123;</span><br><span class="line">            ip = AddressUtils.getHostIp();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> String zkServers = getProperty(properties, CanalConstants.CANAL_ZKSERVERS);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(zkServers)) &#123;</span><br><span class="line">            zkclientx = ZkClientx.getZkClient(zkServers);</span><br><span class="line">            <span class="comment">// 初始化系统目录           </span></span><br><span class="line">          zkclientx.createPersistent(ZookeeperPathUtils.DESTINATION_ROOT_NODE, <span class="keyword">true</span>);</span><br><span class="line">            zkclientx.createPersistent(ZookeeperPathUtils.CANAL_CLUSTER_ROOT_NODE, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4 CanalInstance运行状态监控</span></span><br><span class="line">        <span class="keyword">final</span> ServerRunningData serverData = <span class="keyword">new</span> ServerRunningData(cid, ip + <span class="string">":"</span> + port);</span><br><span class="line">        ServerRunningMonitors.setServerData(serverData);</span><br><span class="line">        ServerRunningMonitors.setRunningMonitors(<span class="comment">//...);</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//5、autoScan机制相关代码    </span></span><br><span class="line">       autoScan = BooleanUtils.toBoolean(getProperty(properties, CanalConstants.CANAL_AUTO_SCAN));</span><br><span class="line">        <span class="keyword">if</span> (autoScan) &#123;</span><br><span class="line">            defaultAction = <span class="keyword">new</span> InstanceAction() &#123;<span class="comment">//....&#125;;</span></span><br><span class="line"> </span><br><span class="line">            instanceConfigMonitors = <span class="comment">//....</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了读者能够尽量容易的看出CanalController的构造方法中都做了什么，上面代码片段中省略了部分代码。这样，我们可以很明显的看出来， ，在CanalController构造方法中的代码分划分为了固定的几个处理步骤，下面按照几个步骤的划分，逐一进行讲解，并详细的介绍CanalController中定义的各个字段的作用。</p>
<h2 id="配置解析相关代码"><a href="#配置解析相关代码" class="headerlink" title="配置解析相关代码"></a>配置解析相关代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化全局参数设置       </span></span><br><span class="line">globalInstanceConfig = initGlobalConfig(properties);</span><br><span class="line">instanceConfigs = <span class="keyword">new</span> MapMaker().makeMap();</span><br><span class="line"><span class="comment">// 初始化instance config       </span></span><br><span class="line">initInstanceConfig(properties);</span><br></pre></td></tr></table></figure>
<h3 id="globalInstanceConfig字段"><a href="#globalInstanceConfig字段" class="headerlink" title="globalInstanceConfig字段"></a>globalInstanceConfig字段</h3><p>表示canal instance的全局配置，类型为InstanceConfig，通过initGlobalConfig方法进行初始化。主要用于解析canal.properties以下几个配置项：</p>
<ul>
<li><code>canal.instance.global.mode</code>：确定canal instance配置加载方式，取值有manager|spring两种方式</li>
<li><code>canal.instance.global.lazy</code>：确定canal instance是否延迟初始化</li>
<li><code>canal.instance.global.manager.address</code>：配置中心地址。如果canal.instance.global.mode=manager，需要提供此配置项</li>
<li><code>canal.instance.global.spring.xml</code>：spring配置文件路径。如果canal.instance.global.mode=spring，需要提供此配置项</li>
</ul>
<p>initGlobalConfig源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InstanceConfig <span class="title">initGlobalConfig</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    InstanceConfig globalConfig = <span class="keyword">new</span> InstanceConfig();</span><br><span class="line">    <span class="comment">//读取canal.instance.global.mode</span></span><br><span class="line">    String modeStr = getProperty(properties, CanalConstants.getInstanceModeKey(CanalConstants.GLOBAL_NAME));</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotEmpty(modeStr)) &#123;</span><br><span class="line">        <span class="comment">//将modelStr转成枚举InstanceMode，这是一个枚举类，只有2个取值，SPRING\MANAGER，对应两种配置方式</span></span><br><span class="line">        globalConfig.setMode(InstanceMode.valueOf(StringUtils.upperCase(modeStr)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取canal.instance.global.lazy</span></span><br><span class="line">    String lazyStr = getProperty(properties, CanalConstants.getInstancLazyKey(CanalConstants.GLOBAL_NAME));</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotEmpty(lazyStr)) &#123;</span><br><span class="line">        globalConfig.setLazy(Boolean.valueOf(lazyStr));</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//读取canal.instance.global.manager.address</span></span><br><span class="line">    String managerAddress = getProperty(properties,</span><br><span class="line">        CanalConstants.getInstanceManagerAddressKey(CanalConstants.GLOBAL_NAME));</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotEmpty(managerAddress)) &#123;</span><br><span class="line">        globalConfig.setManagerAddress(managerAddress);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取canal.instance.global.spring.xml</span></span><br><span class="line">    String springXml = getProperty(properties, CanalConstants.getInstancSpringXmlKey(CanalConstants.GLOBAL_NAME));</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotEmpty(springXml)) &#123;</span><br><span class="line">        globalConfig.setSpringXml(springXml);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    instanceGenerator = <span class="comment">//...初始化instanceGenerator </span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> globalConfig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中canal.instance.global.mode用于确定canal instance的全局配置加载方式，其取值范围有2个：spring、manager。我们知道一个canal server中可以启动多个canal instance，每个instance都有各自的配置。instance的配置也可以放在本地，也可以放在远程配置中心里。我们可以自定义每个canal instance配置文件存储的位置，如果所有canal instance的配置都在本地或者远程，此时我们就可以通过canal.instance.global.mode这个配置项，来统一的指定配置文件的位置，避免为每个canal instance单独指定。</p>
<p>其中：</p>
<p><strong>spring方式：</strong></p>
<p>表示所有的canal instance的配置文件位于本地。此时，我们必须提供配置项canal.instance.global.spring.xml指定spring配置文件的路径。canal提供了多个spring配置文件：file-instance.xml、default-instance.xml、memory-instance.xml、local-instance.xml、group-instance.xml。这么多配置文件主要是为了支持canal instance不同的工作方式。我们在稍后将会讲解各个配置文件的区别。而在这些配置文件的开头，我们无一例外的可以看到以下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.alibaba.otter.canal.instance.spring.support.PropertyPlaceholderConfigurer"</span> <span class="attr">lazy-init</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"ignoreResourceNotFound"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"systemPropertiesModeName"</span> <span class="attr">value</span>=<span class="string">"SYSTEM_PROPERTIES_MODE_OVERRIDE"</span>/&gt;</span><span class="comment">&lt;!-- 允许system覆盖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"locationNames"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:canal.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:$&#123;canal.instance.destination:&#125;/instance.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里我们可以看到，所谓通过spring方式加载canal instance配置，无非就是通过spring提供的PropertyPlaceholderConfigurer来加载canal instance的配置文件instance.properties。</p>
<p>这里instance.properties的文件完整路径是${canal.instance.destination:}/instance.properties，其中${canal.instance.destination}是一个变量。这是因为我们可以在一个canal server中配置多个canal instance，每个canal instance配置文件的名称都是instance.properties，因此我们需要通过目录进行区分。例如我们通过配置项canal.destinations指定多个canal instance的名字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canal.destinations= example1,example2</span><br></pre></td></tr></table></figure>
<p>此时我们就要conf目录下，新建两个子目录example1和example2，每个目录下各自放置一个instance.properties。</p>
<p>canal在初始化时就会分别使用example1和example2来替换${canal.instance.destination:}，从而分别根据example1/instance.properties和example2/instance.properties创建2个canal instance。</p>
<p><strong>manager方式：</strong></p>
<p>表示所有的canal instance的配置文件位于远程配置中心，此时我们必须提供配置项 canal.instance.global.manager.address来指定远程配置中心的地址。目前alibaba内部配置使用这种方式。开发者可以自己实现CanalConfigClient，连接各自的管理系统，完成接入。</p>
<h3 id="instanceGenerator字段"><a href="#instanceGenerator字段" class="headerlink" title="instanceGenerator字段"></a>instanceGenerator字段</h3><p>类型为<code>CanalInstanceGenerator</code>。在<code>initGlobalConfig</code>方法中，除了创建了<code>globalInstanceConfig</code>实例，同时还为字段<code>instanceGenerator</code>字段进行了赋值。</p>
<p>顾名思义，这个字段用于创建<code>CanalInstance</code>实例。这是instance模块中的类，其作用就是为canal.properties文件中canal.destinations配置项列出的每个destination，创建一个CanalInstance实例。CanalInstanceGenerator是一个接口，定义如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CanalInstanceGenerator</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 destination 产生特定的 &#123;<span class="doctag">@link</span> CanalInstance&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">CanalInstance <span class="title">generate</span><span class="params">(String destination)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对spring和manager两种instance配置的加载方式，CanalInstanceGenerator提供了两个对应的实现类，如下所示：</p>
<img src="/2020/02/06/CANAL源码解析-deployer模块/4.png">
<p>instanceGenerator字段通过一个匿名内部类进行初始化。其内部会判断配置的各个destination的配置加载方式，spring 或者manager。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">instanceGenerator = <span class="keyword">new</span> CanalInstanceGenerator() &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> CanalInstance <span class="title">generate</span><span class="params">(String destination)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//1、根据destination从instanceConfigs获取对应的InstanceConfig对象</span></span><br><span class="line">            InstanceConfig config = instanceConfigs.get(destination);</span><br><span class="line">            <span class="keyword">if</span> (config == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> CanalServerException(<span class="string">"can't find destination:&#123;&#125;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//2、如果destination对应的InstanceConfig的mode是manager方式，使用ManagerCanalInstanceGenerator</span></span><br><span class="line">            <span class="keyword">if</span> (config.getMode().isManager()) &#123;</span><br><span class="line">                ManagerCanalInstanceGenerator instanceGenerator = <span class="keyword">new</span> ManagerCanalInstanceGenerator();</span><br><span class="line">                instanceGenerator.setCanalConfigClient(managerClients.get(config.getManagerAddress()));</span><br><span class="line">                <span class="keyword">return</span> instanceGenerator.generate(destination);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config.getMode().isSpring()) &#123;</span><br><span class="line">          <span class="comment">//3、如果destination对应的InstanceConfig的mode是spring方式，使用SpringCanalInstanceGenerator</span></span><br><span class="line">                SpringCanalInstanceGenerator instanceGenerator = <span class="keyword">new</span> SpringCanalInstanceGenerator();</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 设置当前正在加载的通道，加载spring查找文件时会用到该变量                        </span></span><br><span class="line">                        System.setProperty(CanalConstants.CANAL_DESTINATION_PROPERTY, destination);</span><br><span class="line">                        instanceGenerator.setBeanFactory(getBeanFactory(config.getSpringXml()));</span><br><span class="line">                        <span class="keyword">return</span> instanceGenerator.generate(destination);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        logger.error(<span class="string">"generator instance failed."</span>, e);</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> CanalException(e);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        System.setProperty(CanalConstants.CANAL_DESTINATION_PROPERTY, <span class="string">""</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"unknow mode :"</span> + config.getMode());</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>上述代码中的第1步比较变态，从instanceConfigs中根据destination作为参数，获得对应的InstanceConfig。而instanceConfigs目前还没有被初始化，这个字段是在稍后将要讲解的initInstanceConfig方法初始化的，不过由于这是一个引用类型，当initInstanceConfig方法被执行后，instanceConfigs字段中也就有值了。目前，我们姑且认为， instanceConfigs这个Map<string, instanceconfig="">类型的字段已经被初始化好了。  </string,></p>
<p>2、3两步用于确定是instance的配置加载方式是spring还是manager，如果是spring，就使用SpringCanalInstanceGenerator创建CanalInstance实例，如果是manager，就使用ManagerCanalInstanceGenerator创建CanalInstance实例。</p>
<p>由于目前manager方式的源码并未开源，因此，我们只分析SpringCanalInstanceGenerator相关代码。</p>
<p>上述代码中，首先创建了一个SpringCanalInstanceGenerator实例，然后往里面设置了一个BeanFactory。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instanceGenerator.setBeanFactory(getBeanFactory(config.getSpringXml()));</span><br></pre></td></tr></table></figure>
<p>其中config.getSpringXml()返回的就是我们在canal.properties中通过canal.instance.global.spring.xml配置项指定了spring配置文件路径。getBeanFactory方法源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> BeanFactory <span class="title">getBeanFactory</span><span class="params">(String springXml)</span> </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(springXml);</span><br><span class="line">        <span class="keyword">return</span> applicationContext;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>往<code>SpringCanalInstanceGenerator</code>设置了BeanFactory之后，就可以通过其的generate方法获得CanalInstance实例。</p>
<p>SpringCanalInstanceGenerator的源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCanalInstanceGenerator</span> <span class="keyword">implements</span> <span class="title">CanalInstanceGenerator</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String      defaultName = <span class="string">"instance"</span>;</span><br><span class="line">    <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> CanalInstance <span class="title">generate</span><span class="params">(String destination)</span> </span>&#123;</span><br><span class="line">        String beanName = destination;</span><br><span class="line">        <span class="comment">//首先判断beanFactory是否包含以destination为id的bean</span></span><br><span class="line">        <span class="keyword">if</span> (!beanFactory.containsBean(beanName)) &#123;</span><br><span class="line">            beanName = defaultName;<span class="comment">//如果没有，设置要获取的bean的id为instance。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//以默认的bean的id值"instance"来获取CanalInstance实例</span></span><br><span class="line">        <span class="keyword">return</span> (CanalInstance) beanFactory.getBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先尝试以传入的参数destination来获取CanalInstance实例，如果没有，就以默认的bean的id值”instance”来获取CanalInstance实例。事实上，如果你没有修改spring配置文件，那么默认的名字就是instance。事实上，在canal提供的各个spring配置文件xxx-instance.xml中，都有类似以下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"instance"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.otter.canal.instance.spring.CanalInstanceWithSpring"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"destination"</span> <span class="attr">value</span>=<span class="string">"$&#123;canal.instance.destination&#125;"</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"eventParser"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"eventParser"</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"eventSink"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"eventSink"</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"eventStore"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"eventStore"</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"metaManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"metaManager"</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"alarmHandler"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"alarmHandler"</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码片段中，我们看到的确有一个bean的名字是instance，其类型是<code>CanalInstanceWithSpring</code>，这是<code>CanalInstance</code>接口的实现类。类似的，我们可以想到在manager配置方式下，获取的CanalInstance实现类是<code>CanalInstanceWithManager</code>。事实上，你想的没错，<code>CanalInstance</code>的类图继承关系如下所示：</p>
<img src="/2020/02/06/CANAL源码解析-deployer模块/5.png">
<p>需要注意的是，到目前为止，我们只是创建好了CanalInstanceGenerator，而CanalInstance尚未创建。在CanalController的start方法被调用时，CanalInstance才会被真正的创建，相关源码将在稍后分析。</p>
<h3 id="instanceConfigs字段"><a href="#instanceConfigs字段" class="headerlink" title="instanceConfigs字段"></a>instanceConfigs字段</h3><p>类型为<code>Map&lt;String, InstanceConfig&gt;</code>。前面提到初始化instanceGenerator后，当其generate方法被调用时，会尝试从instanceConfigs根据一个destination获取对应的InstanceConfig，现在分析instanceConfigs的相关初始化代码。</p>
<p>我们知道<code>globalInstanceConfig</code>定义全局的配置加载方式。如果需要把部分<code>CanalInstance</code>配置放于本地，另外一部分<code>CanalIntance</code>配置放于远程配置中心，则只通过全局方式配置，无法达到这个要求。虽然这种情况很少见，但是为了提供最大的灵活性，canal支持每个<code>CanalIntance</code>自己来定义自己的加载方式，来覆盖默认的全局配置加载方式。而每个destination对应的<code>InstanceConfig</code>配置就存放于instanceConfigs字段中。</p>
<p>举例来说：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前server上部署的instance列表</span></span><br><span class="line">canal.destinations=instance1,instance2 </span><br><span class="line"> </span><br><span class="line"><span class="comment">//instance配置全局加载方式</span></span><br><span class="line">canal.instance.global.mode = spring</span><br><span class="line">canal.instance.global.lazy = <span class="keyword">false</span></span><br><span class="line">canal.instance.global.spring.xml = classpath:spring/file-instance.xml</span><br><span class="line"> </span><br><span class="line"><span class="comment">//instance1覆盖全局加载方式</span></span><br><span class="line">canal.instance.instance1.mode = manager</span><br><span class="line">canal.instance.instance1.manager.address = <span class="number">127.0</span>.0.1:<span class="number">1099</span></span><br><span class="line">canal.instance.instance1.lazy = tue</span><br></pre></td></tr></table></figure>
<p>这段配置中，设置了instance的全局加载方式为spring，instance1覆盖了全局配置，使用manager方式加载配置。而instance2没有覆盖配置，因此默认使用spring加载方式。</p>
<p>instanceConfigs字段通过initInstanceConfig方法进行初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">instanceConfigs = <span class="keyword">new</span> MapMaker().makeMap();<span class="comment">//这里利用Google Guava框架的MapMaker创建Map实例并赋值给instanceConfigs</span></span><br><span class="line"><span class="comment">// 初始化instance config</span></span><br><span class="line">initInstanceConfig(properties);</span><br></pre></td></tr></table></figure>
<p>initInstanceConfig方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initInstanceConfig</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//读取配置项canal.destinations</span></span><br><span class="line">    String destinationStr = getProperty(properties, CanalConstants.CANAL_DESTINATIONS);</span><br><span class="line">    <span class="comment">//以","分割canal.destinations，得到一个数组形式的destination</span></span><br><span class="line">    String[] destinations = StringUtils.split(destinationStr, CanalConstants.CANAL_DESTINATION_SPLIT);</span><br><span class="line">    <span class="keyword">for</span> (String destination : destinations) &#123;</span><br><span class="line">        <span class="comment">//为每一个destination生成一个InstanceConfig实例</span></span><br><span class="line">        InstanceConfig config = parseInstanceConfig(properties, destination);</span><br><span class="line">        <span class="comment">//将destination对应的InstanceConfig放入instanceConfigs中</span></span><br><span class="line">        InstanceConfig oldConfig = instanceConfigs.put(destination, config);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (oldConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.warn(<span class="string">"destination:&#123;&#125; old config:&#123;&#125; has replace by new config:&#123;&#125;"</span>, <span class="keyword">new</span> Object[] &#123; destination,</span><br><span class="line">                    oldConfig, config &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码片段中，首先解析canal.destinations配置项，可以理解一个destination就对应要初始化一个canal instance。针对每个destination会创建各自的InstanceConfig，最终都会放到instanceConfigs这个Map中。</p>
<p>各个destination对应的InstanceConfig都是通过parseInstanceConfig方法来解析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InstanceConfig <span class="title">parseInstanceConfig</span><span class="params">(Properties properties, String destination)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//每个destination对应的InstanceConfig都引用了全局的globalInstanceConfig</span></span><br><span class="line">    InstanceConfig config = <span class="keyword">new</span> InstanceConfig(globalInstanceConfig);</span><br><span class="line">    <span class="comment">//...其他几个配置项与获取globalInstanceConfig类似，不再赘述，唯一注意的的是配置项的key部分中的global变成传递进来的destination</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时我们可以看一下InstanceConfig类的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceConfig</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> InstanceConfig globalConfig;</span><br><span class="line">    <span class="keyword">private</span> InstanceMode   mode;</span><br><span class="line">    <span class="keyword">private</span> Boolean        lazy;</span><br><span class="line">    <span class="keyword">private</span> String         managerAddress;</span><br><span class="line">    <span class="keyword">private</span> String         springXml;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InstanceConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InstanceConfig</span><span class="params">(InstanceConfig globalConfig)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.globalConfig = globalConfig;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> InstanceMode &#123;</span><br><span class="line">        SPRING, MANAGER;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSpring</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span> == InstanceMode.SPRING;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span> == InstanceMode.MANAGER;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getLazy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazy == <span class="keyword">null</span> &amp;&amp; globalConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> globalConfig.getLazy();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> lazy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLazy</span><span class="params">(Boolean lazy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lazy = lazy;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> InstanceMode <span class="title">getMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mode == <span class="keyword">null</span> &amp;&amp; globalConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> globalConfig.getMode();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMode</span><span class="params">(InstanceMode mode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mode = mode;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getManagerAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (managerAddress == <span class="keyword">null</span> &amp;&amp; globalConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> globalConfig.getManagerAddress();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> managerAddress;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setManagerAddress</span><span class="params">(String managerAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.managerAddress = managerAddress;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSpringXml</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (springXml == <span class="keyword">null</span> &amp;&amp; globalConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> globalConfig.getSpringXml();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> springXml;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSpringXml</span><span class="params">(String springXml)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.springXml = springXml;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ToStringBuilder.reflectionToString(<span class="keyword">this</span>, CanalToStringStyle.DEFAULT_STYLE);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，InstanceConfig类中维护了一个globalConfig字段，其类型也是InstanceConfig。而其相关get方法在执行时，会按照以下逻辑进行判断：如果没有自身没有这个配置，则返回全局配置，如果有，则返回自身的配置。通过这种方式实现对全局配置的覆盖。</p>
<h2 id="准备canal-server相关代码"><a href="#准备canal-server相关代码" class="headerlink" title="准备canal server相关代码"></a>准备canal server相关代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">cid = Long.valueOf(getProperty(properties, CanalConstants.CANAL_ID));</span><br><span class="line">ip = getProperty(properties, CanalConstants.CANAL_IP);</span><br><span class="line">port = Integer.valueOf(getProperty(properties, CanalConstants.CANAL_PORT));</span><br><span class="line"> </span><br><span class="line">embededCanalServer = CanalServerWithEmbedded.instance();</span><br><span class="line">embededCanalServer.setCanalInstanceGenerator(instanceGenerator);<span class="comment">// 设置自定义的instanceGenerator</span></span><br><span class="line">canalServer = CanalServerWithNetty.instance();</span><br><span class="line">canalServer.setIp(ip);</span><br><span class="line">canalServer.setPort(port);</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">上述代码中，首先解析了cid、ip、port字段，其中：</span><br><span class="line"></span><br><span class="line">- **cid：Long**，对应canal.properties文件中的canal.id，目前无实际用途</span><br><span class="line">- **ip：String**，对应canal.properties文件中的canal.ip，canal server监听的ip。</span><br><span class="line">- **port：<span class="keyword">int</span>**，对应canal.properties文件中的canal.port，canal server监听的端口</span><br><span class="line">  </span><br><span class="line">之后分别为以下两个字段赋值：</span><br><span class="line"></span><br><span class="line">- **embededCanalServer：**类型为CanalServerWithEmbedded </span><br><span class="line">- **canalServer：**类型为CanalServerWithNetty</span><br><span class="line"></span><br><span class="line">`CanalServerWithEmbedded` 和 `CanalServerWithNetty`都实现了CanalServer接口，且都实现了单例模式，通过静态方法instance获取实例。</span><br><span class="line"></span><br><span class="line">关于这两种类型的实现，canal官方文档有以下描述：</span><br><span class="line"></span><br><span class="line">&#123;%asset_img <span class="number">6</span>.png%&#125;</span><br><span class="line"></span><br><span class="line">说白了，就是我们可以不必独立部署canal server。在应用直接使用CanalServerWithEmbedded直连mysql数据库。如果觉得自己的技术hold不住相关代码，就独立部署一个canal server，使用canal提供的客户端，连接canal server获取binlog解析后数据。而CanalServerWithNetty是在CanalServerWithEmbedded的基础上做的一层封装，用于与客户端通信。   </span><br><span class="line"></span><br><span class="line">在独立部署canal server时，Canal客户端发送的所有请求都交给CanalServerWithNetty处理解析，解析完成之后委派给了交给CanalServerWithEmbedded进行处理。因此CanalServerWithNetty就是一个马甲而已。CanalServerWithEmbedded才是核心。</span><br><span class="line"></span><br><span class="line">因此，在上述代码中，我们看到，用于生成CanalInstance实例的instanceGenerator被设置到了CanalServerWithEmbedded中，而ip和port被设置到CanalServerWithNetty中。</span><br><span class="line"></span><br><span class="line">关于CanalServerWithNetty如何将客户端的请求委派给CanalServerWithEmbedded进行处理，我们将在server模块源码分析中进行讲解。</span><br><span class="line"></span><br><span class="line">## 初始化zk相关代码</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">   <span class="comment">//读取canal.properties中的配置项canal.zkServers，如果没有这个配置，则表示项目不使用zk</span></span><br><span class="line"><span class="keyword">final</span> String zkServers = getProperty(properties, CanalConstants.CANAL_ZKSERVERS);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isNotEmpty(zkServers)) &#123;</span><br><span class="line">    <span class="comment">//创建zk实例</span></span><br><span class="line">    zkclientx = ZkClientx.getZkClient(zkServers);</span><br><span class="line">    <span class="comment">// 初始化系统目录</span></span><br><span class="line">    <span class="comment">//destination列表，路径为/otter/canal/destinations</span></span><br><span class="line">    zkclientx.createPersistent(ZookeeperPathUtils.DESTINATION_ROOT_NODE, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//整个canal server的集群列表，路径为/otter/canal/cluster</span></span><br><span class="line">    zkclientx.createPersistent(ZookeeperPathUtils.CANAL_CLUSTER_ROOT_NODE, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>canal支持利用了zk来完成HA机制、以及将当前消费到到的mysql的binlog位置记录到zk中。ZkClientx是canal对ZkClient进行了一层简单的封装。</p>
<p>显然，当我们没有配置canal.zkServers，那么zkclientx不会被初始化。</p>
<p>关于Canal如何利用ZK做HA，我们将在稍后的代码中进行分。而利用zk记录binlog的消费进度，将在之后的章节进行分析。</p>
<h2 id="CanalInstance运行状态监控相关代码"><a href="#CanalInstance运行状态监控相关代码" class="headerlink" title="CanalInstance运行状态监控相关代码"></a>CanalInstance运行状态监控相关代码</h2><p>由于这段代码比较长且恶心，这里笔者暂时对部分代码进行省略，以便读者看清楚整各脉络</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ServerRunningData serverData = <span class="keyword">new</span> ServerRunningData(cid, ip + <span class="string">":"</span> + port);</span><br><span class="line">        ServerRunningMonitors.setServerData(serverData);</span><br><span class="line">        ServerRunningMonitors.setRunningMonitors(MigrateMap.makeComputingMap(<span class="keyword">new</span> Function&lt;String, ServerRunningMonitor&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> ServerRunningMonitor <span class="title">apply</span><span class="params">(<span class="keyword">final</span> String destination)</span> </span>&#123;</span><br><span class="line">                ServerRunningMonitor runningMonitor = <span class="keyword">new</span> ServerRunningMonitor(serverData);</span><br><span class="line">                runningMonitor.setDestination(destination);</span><br><span class="line">                runningMonitor.setListener(<span class="keyword">new</span> ServerRunningListener() &#123;....&#125;);<span class="comment">//省略ServerRunningListener的具体实现</span></span><br><span class="line">                <span class="keyword">if</span> (zkclientx != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    runningMonitor.setZkClient(zkclientx);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 触发创建一下cid节点</span></span><br><span class="line">                runningMonitor.init();</span><br><span class="line">                <span class="keyword">return</span> runningMonitor;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br></pre></td></tr></table></figure>
<p>上述代码中，<code>ServerRunningMonitors</code>是ServerRunningMonitor对象的容器，而ServerRunningMonitor用于监控CanalInstance。</p>
<p>canal会为每一个destination创建一个CanalInstance，每个CanalInstance都会由一个ServerRunningMonitor来进行监控。而ServerRunningMonitor统一由ServerRunningMonitors进行管理。</p>
<p>除了CanalInstance需要监控，CanalServer本身也需要监控。因此我们在代码一开始，就看到往ServerRunningMonitors设置了一个ServerRunningData对象，封装了canal server监听的ip和端口等信息。</p>
<p>ServerRunningMonitors源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerRunningMonitors</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ServerRunningData serverData;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map               runningMonitors; <span class="comment">// &lt;String,ServerRunningMonitor&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ServerRunningData <span class="title">getServerData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serverData;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, ServerRunningMonitor&gt; <span class="title">getRunningMonitors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> runningMonitors;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ServerRunningMonitor <span class="title">getRunningMonitor</span><span class="params">(String destination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ServerRunningMonitor) runningMonitors.get(destination);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setServerData</span><span class="params">(ServerRunningData serverData)</span> </span>&#123;</span><br><span class="line">        ServerRunningMonitors.serverData = serverData;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setRunningMonitors</span><span class="params">(Map runningMonitors)</span> </span>&#123;</span><br><span class="line">        ServerRunningMonitors.runningMonitors = runningMonitors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ServerRunningMonitors的setRunningMonitors方法接收的参数是一个Map，其中Map的key是destination，value是ServerRunningMonitor，也就是说针对每一个destination都有一个ServerRunningMonitor来监控。</p>
<p>上述代码中，在往ServerRunningMonitors设置Map时，是通过MigrateMap.makeComputingMap方法来创建的，其接受一个Function类型的参数，这是guava中定义的接口，其声明了apply抽象方法。其工作原理可以通过下面代码片段进行介绍：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, User&gt; map = MigrateMap.makeComputingMap(<span class="keyword">new</span> Function&lt;String, User&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> User <span class="title">apply</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> User(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">User user = map.get(<span class="string">"tianshouzhi"</span>);<span class="comment">//第一次获取时会创建</span></span><br><span class="line"><span class="keyword">assert</span> user != <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">assert</span> user == map.get(<span class="string">"tianshouzhi"</span>);<span class="comment">//之后获取，总是返回之前已经创建的对象</span></span><br></pre></td></tr></table></figure>
<p>这段代码中，我们利用MigrateMap.makeComputingMap创建了一个Map，其中key为String类型，value为User类型。当我们调用map.get(“tianshouzhi”)方法，最开始这个Map中并没有任何key/value的，于是其就会回调Function的apply方法，利用参数”tianshouzhi”创建一个User对象并返回。之后当我们再以”tianshouzhi”为key从Map中获取User对象时，会直接将前面创建的对象返回。不会回调apply方法，也就是说，只有在第一次尝试获取时，才会回调apply方法。</p>
<p>而在上述代码中，实际上就利用了这个特性，只不过是根据destination获取ServerRunningMonitor对象，如果不存在就创建。</p>
<p>在创建ServerRunningMonitor对象时，首先根据ServerRunningData创建ServerRunningMonitor实例，之后设置了destination和ServerRunningListener对象，接着，判断如果zkClientx字段如果不为空，也设置到ServerRunningMonitor中，最后调用init方法进行初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ServerRunningMonitor runningMonitor = <span class="keyword">new</span> ServerRunningMonitor(serverData);</span><br><span class="line">runningMonitor.setDestination(destination);</span><br><span class="line">runningMonitor.setListener(<span class="keyword">new</span> ServerRunningListener()&#123;...&#125;)<span class="comment">//省略ServerRunningListener具体代码</span></span><br><span class="line"><span class="keyword">if</span> (zkclientx != <span class="keyword">null</span>) &#123;</span><br><span class="line">runningMonitor.setZkClient(zkclientx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 触发创建一下cid节点</span></span><br><span class="line">runningMonitor.init();</span><br><span class="line"><span class="keyword">return</span> runningMonitor;</span><br></pre></td></tr></table></figure>
<p>ServerRunningListener的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ServerRunningListener() &#123;</span><br><span class="line">    <span class="comment">/*内部调用了embededCanalServer的start(destination)方法。</span></span><br><span class="line"><span class="comment">    此处需要划重点，说明每个destination对应的CanalInstance是通过embededCanalServer的start方法启动的，</span></span><br><span class="line"><span class="comment">    这与我们之前分析将instanceGenerator设置到embededCanalServer中可以对应上。</span></span><br><span class="line"><span class="comment">    embededCanalServer负责调用instanceGenerator生成CanalInstance实例，并负责其启动。*/</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processActiveEnter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             MDC.put(CanalConstants.MDC_DESTINATION, String.valueOf(destination));</span><br><span class="line">             embededCanalServer.start(destination);</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             MDC.remove(CanalConstants.MDC_DESTINATION);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  <span class="comment">//内部调用embededCanalServer的stop(destination)方法。与上start方法类似，只不过是停止CanalInstance。</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processActiveExit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             MDC.put(CanalConstants.MDC_DESTINATION, String.valueOf(destination));</span><br><span class="line">             embededCanalServer.stop(destination);</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             MDC.remove(CanalConstants.MDC_DESTINATION);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/*处理存在zk的情况下，在Canalinstance启动之前，在zk中创建节点。</span></span><br><span class="line"><span class="comment">     路径为：/otter/canal/destinations/&#123;0&#125;/cluster/&#123;1&#125;，其0会被destination替换，1会被ip:port替换。</span></span><br><span class="line"><span class="comment">     此方法会在processActiveEnter()之前被调用*/</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (zkclientx != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="keyword">final</span> String path = ZookeeperPathUtils.getDestinationClusterNode(destination, ip + <span class="string">":"</span> + port);</span><br><span class="line">                 initCid(path);</span><br><span class="line">                 zkclientx.subscribeStateChanges(<span class="keyword">new</span> IZkStateListener() &#123;</span><br><span class="line">                     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleStateChanged</span><span class="params">(KeeperState state)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNewSession</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                         initCid(path);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             MDC.remove(CanalConstants.MDC_DESTINATION);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">//处理存在zk的情况下，在Canalinstance停止前，释放zk节点，路径为/otter/canal/destinations/&#123;0&#125;/cluster/&#123;1&#125;，</span></span><br><span class="line"><span class="comment">//其0会被destination替换，1会被ip:port替换。此方法会在processActiveExit()之前被调用</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             MDC.put(CanalConstants.MDC_DESTINATION, String.valueOf(destination));</span><br><span class="line">             <span class="keyword">if</span> (zkclientx != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="keyword">final</span> String path = ZookeeperPathUtils.getDestinationClusterNode(destination, ip + <span class="string">":"</span> + port);</span><br><span class="line">                 releaseCid(path);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             MDC.remove(CanalConstants.MDC_DESTINATION);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，我们可以看到启动一个CanalInstance实际上是在ServerRunningListener的processActiveEnter方法中，通过调用embededCanalServer的start(destination)方法进行的，对于停止也是类似。</p>
<p>那么ServerRunningListener中的相关方法到底是在哪里回调的呢？我们可以在ServerRunningMonitor的start和stop方法中找到答案，这里只列出start方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerRunningMonitor</span> <span class="keyword">extends</span> <span class="title">AbstractCanalLifeCycle</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.start();</span><br><span class="line">    processStart();<span class="comment">//其内部会调用ServerRunningListener的processStart()方法</span></span><br><span class="line">    <span class="keyword">if</span> (zkClient != <span class="keyword">null</span>) &#123;<span class="comment">//存在zk，以HA方式启动</span></span><br><span class="line">        <span class="comment">// 如果需要尽可能释放instance资源，不需要监听running节点，不然即使stop了这台机器，另一台机器立马会start</span></span><br><span class="line">        String path = ZookeeperPathUtils.getDestinationServerRunning(destination);</span><br><span class="line">        zkClient.subscribeDataChanges(path, dataListener);</span><br><span class="line"> </span><br><span class="line">        initRunning();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//没有zk，直接启动</span></span><br><span class="line">        processActiveEnter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//...stop方法逻辑类似，相关代码省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当ServerRunningMonitor的start方法被调用时，其首先会直接调用processStart方法，这个方法内部直接调了ServerRunningListener的processStart()方法，源码如下所示。通过前面的分析，我们已经知道在存在zkClient!=null的情况，会往zk中创建一个节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            listener.processStart();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"processStart failed"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后会判断是否存在zkClient，如果不存在，则以本地方式启动，如果存在，则以HA方式启动。我们知道，canal server可以部署成两种方式：集群方式或者独立部署。其中集群方式是利用zk来做HA，独立部署则可以直接进行启动。我们先来看比较简单的直接启动。</p>
<p><strong>直接启动：</strong></p>
<p>不存在zk的情况下，会进入else代码块，调用processActiveEnter方法，其内部调用了listener的processActiveEnter，启动相应destination对应的CanalInstance。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processActiveEnter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            listener.processActiveEnter();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"processActiveEnter failed"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>HA方式启动：</strong></p>
<p>存在zk，说明canal server可能做了集群，因为canal就是利用zk来做HA的。首先根据destination构造一个zk的节点路径，然后进行监听。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*构建临时节点的路径：/otter/canal/destinations/&#123;0&#125;/running，其中占位符&#123;0&#125;会被destination替换。</span></span><br><span class="line"><span class="comment">在集群模式下，可能会有多个canal server共同处理同一个destination，</span></span><br><span class="line"><span class="comment">在某一时刻，只能由一个canal server进行处理，处理这个destination的canal server进入running状态，其他canal server进入standby状态。*/</span></span><br><span class="line">String path = ZookeeperPathUtils.getDestinationServerRunning(destination);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*对destination对应的running节点进行监听，一旦发生了变化，则说明可能其他处理相同destination的canal server可能出现了异常，</span></span><br><span class="line"><span class="comment">此时需要尝试自己进入running状态。*/</span></span><br><span class="line">zkClient.subscribeDataChanges(path, dataListener);</span><br></pre></td></tr></table></figure>
<p>上述只是监听代码，之后尝试调用initRunning方法通过HA的方式来启动CanalInstance。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isStart()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构建临时节点的路径：/otter/canal/destinations/&#123;0&#125;/running，其中占位符&#123;0&#125;会被destination替换</span></span><br><span class="line">    String path = ZookeeperPathUtils.getDestinationServerRunning(destination);</span><br><span class="line">    <span class="comment">// 序列化</span></span><br><span class="line">    <span class="comment">//构建临时节点的数据，标记当前destination由哪一个canal server处理</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = JsonUtils.marshalToByte(serverData);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mutex.set(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//尝试创建临时节点。如果节点已经存在，说明是其他的canal server已经启动了这个canal instance。</span></span><br><span class="line">        <span class="comment">//此时会抛出ZkNodeExistsException，进入catch代码块。</span></span><br><span class="line">        zkClient.create(path, bytes, CreateMode.EPHEMERAL);</span><br><span class="line">        activeData = serverData;</span><br><span class="line">        processActiveEnter();<span class="comment">//如果创建成功，触发一下事件，内部调用ServerRunningListener的processActiveEnter方法</span></span><br><span class="line">        mutex.set(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ZkNodeExistsException e) &#123;</span><br><span class="line">      <span class="comment">//创建节点失败，则根据path从zk中获取当前是哪一个canal server创建了当前canal instance的相关信息。</span></span><br><span class="line">      <span class="comment">//第二个参数true，表示的是，如果这个path不存在，则返回null。</span></span><br><span class="line">        bytes = zkClient.readData(path, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="keyword">null</span>) &#123;<span class="comment">// 如果不存在节点，立即尝试一次            </span></span><br><span class="line">            initRunning();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果的确存在，则将创建该canal instance实例信息存入activeData中。</span></span><br><span class="line">            activeData = JsonUtils.unmarshalFromByte(bytes, ServerRunningData.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ZkNoNodeException e) &#123;<span class="comment">//如果/otter/canal/destinations/&#123;0&#125;/节点不存在，进行创建其中占位符&#123;0&#125;会被destination替换</span></span><br><span class="line">        zkClient.createPersistent(ZookeeperPathUtils.getDestinationPath(destination), <span class="keyword">true</span>); </span><br><span class="line">       <span class="comment">// 尝试创建父节点        </span></span><br><span class="line">        initRunning();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，initRunning方法内部只有在尝试在zk中创建节点成功后，才会去调用listener的processActiveEnter方法来真正启动destination对应的canal instance，这是canal HA方式启动的核心。canal官方文档中介绍了CanalServer HA机制启动的流程，如下：</p>
<ol>
<li>canal server要启动某个canal instance时都先向zookeeper进行一次尝试启动判断(实现：创建EPHEMERAL节点，谁创建成功就运行谁启动)</li>
<li>创建zookeeper节点成功后，对应的canal server就启动对应的canal instance，没有创建成功的canal instance就处于standby状态</li>
<li>一旦zookeeper发现canal server A 创建的节点消失后，立即通知其他的canal server再次进行步骤1的操作，重新选出一个canal server启动instance</li>
</ol>
<p>事实上，这个说明的前两步，都是在initRunning方法中实现的。从上面的代码中，我们可以看出，在HA机启动的情况下，initRunning方法不一定能走到processActiveEnter()方法，因为创建临时节点可能会出错。</p>
<p>此外，根据官方文档说明，如果出错，那么当前canal instance则进入standBy状态。也就是另外一个canal instance出现异常时，当前canal instance顶上去。那么相关源码在什么地方呢？在HA方式启动最开始的2行代码的监听逻辑中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String path = ZookeeperPathUtils.getDestinationServerRunning(destination);</span><br><span class="line">zkClient.subscribeDataChanges(path, dataListener);</span><br></pre></td></tr></table></figure>
<p>其中dataListener类型是<code>IZkDataListener</code>，这是zkclient客户端提供的接口，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IZkDataListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataChange</span><span class="params">(String dataPath, Object data)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataDeleted</span><span class="params">(String dataPath)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当zk节点中的数据发生变更时，会自动回调这两个方法，很明显，一个是用于处理节点数据发生变化，一个是用于处理节点数据被删除。</p>
<p>而dataListener是在ServerRunningMonitor的构造方法中初始化的，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServerRunningMonitor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建父节点</span></span><br><span class="line">    dataListener = <span class="keyword">new</span> IZkDataListener() &#123;</span><br><span class="line">        <span class="comment">//！！！目前看来，好像并没有存在修改running节点数据的代码，为什么这个方法不是空实现？</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataChange</span><span class="params">(String dataPath, Object data)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            MDC.put(<span class="string">"destination"</span>, destination);</span><br><span class="line">            ServerRunningData runningData = JsonUtils.unmarshalFromByte((<span class="keyword">byte</span>[]) data, ServerRunningData.class);</span><br><span class="line">            <span class="keyword">if</span> (!isMine(runningData.getAddress())) &#123;</span><br><span class="line">                mutex.set(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (!runningData.isActive() &amp;&amp; isMine(runningData.getAddress())) &#123; <span class="comment">// 说明出现了主动释放的操作，并且本机之前是active                                   </span></span><br><span class="line">              release = <span class="keyword">true</span>;</span><br><span class="line">                releaseRunning();<span class="comment">// 彻底释放mainstem            &#125;</span></span><br><span class="line"> </span><br><span class="line">            activeData = (ServerRunningData) runningData;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当其他canal instance出现异常，临时节点数据被删除时，会自动回调这个方法，此时当前canal instance要顶上去</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataDeleted</span><span class="params">(String dataPath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            MDC.put(<span class="string">"destination"</span>, destination);</span><br><span class="line">            mutex.set(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (!release &amp;&amp; activeData != <span class="keyword">null</span> &amp;&amp; isMine(activeData.getAddress())) &#123;</span><br><span class="line">                <span class="comment">// 如果上一次active的状态就是本机，则即时触发一下active抢占                </span></span><br><span class="line">                initRunning();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则就是等待delayTime，避免因网络瞬端或者zk异常，导致出现频繁的切换操作                </span></span><br><span class="line">                delayExector.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"> </span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        initRunning();<span class="comment">//尝试自己进入running状态</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, delayTime, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么现在问题来了？ServerRunningMonitor的start方法又是在哪里被调用的， 这个方法被调用了，才能真正的启动canal instance。这部分代码我们放到后面的CanalController中的start方法进行讲解。</p>
<p>下面分析最后一部分代码，autoScan机制相关代码。</p>
<h2 id="autoScan机制相关代码"><a href="#autoScan机制相关代码" class="headerlink" title="autoScan机制相关代码"></a>autoScan机制相关代码</h2><p>关于autoscan，官方文档有以下介绍：</p>
<img src="/2020/02/06/CANAL源码解析-deployer模块/7.png">
<p>结合autoscan机制的相关源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">autoScan = BooleanUtils.toBoolean(getProperty(properties, CanalConstants.CANAL_AUTO_SCAN));</span><br><span class="line">        <span class="keyword">if</span> (autoScan) &#123;</span><br><span class="line">            defaultAction = <span class="keyword">new</span> InstanceAction() &#123;<span class="comment">//....&#125;;</span></span><br><span class="line"> </span><br><span class="line">            instanceConfigMonitors = <span class="comment">//....</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，autoScan是否需要自动扫描的开关，只有当autoScan为true时，才会初始化defaultAction字段和instanceConfigMonitors字段。其中：</p>
<p>其中：</p>
<ul>
<li><p><strong>defaultAction</strong> 其作用是如果配置发生了变更，默认应该采取什么样的操作。其实现了InstanceAction接口定义的三个抽象方法：start、stop和reload。当新增一个destination配置时，需要调用start方法来启动；当移除一个destination配置时，需要调用stop方法来停止；当某个destination配置发生变更时，需要调用reload方法来进行重启。</p>
</li>
<li><p><strong>instanceConfigMonitors</strong> 类型为Map<instancemode, instanceconfigmonitor="">。defaultAction字段只是定义了配置发生变化默认应该采取的操作，那么总该有一个类来监听配置是否发生了变化，这就是InstanceConfigMonitor的作用。官方文档中，只提到了对canal.conf.dir配置项指定的目录的监听，这指的是通过spring方式加载配置。显然的，通过manager方式加载配置，配置中心的内容也是可能发生变化的，也需要进行监听。此时可以理解为什么instanceConfigMonitors的类型是一个Map，key为InstanceMode，就是为了对这两种方式的配置加载方式都进行监听。</instancemode,></p>
</li>
</ul>
<p>defaultAction字段初始化源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">defaultAction = <span class="keyword">new</span> InstanceAction() &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(String destination)</span> </span>&#123;</span><br><span class="line">        InstanceConfig config = instanceConfigs.get(destination);</span><br><span class="line">        <span class="keyword">if</span> (config == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 重新读取一下instance config</span></span><br><span class="line">            config = parseInstanceConfig(properties, destination);</span><br><span class="line">            instanceConfigs.put(destination, config);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (!embededCanalServer.isStart(destination)) &#123;</span><br><span class="line">            <span class="comment">// HA机制启动</span></span><br><span class="line">            ServerRunningMonitor runningMonitor = ServerRunningMonitors.getRunningMonitor(destination);</span><br><span class="line">            <span class="keyword">if</span> (!config.getLazy() &amp;&amp; !runningMonitor.isStart()) &#123;</span><br><span class="line">                runningMonitor.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">(String destination)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处的stop，代表强制退出，非HA机制，所以需要退出HA的monitor和配置信息</span></span><br><span class="line">        InstanceConfig config = instanceConfigs.remove(destination);</span><br><span class="line">        <span class="keyword">if</span> (config != <span class="keyword">null</span>) &#123;</span><br><span class="line">            embededCanalServer.stop(destination);</span><br><span class="line">            ServerRunningMonitor runningMonitor = ServerRunningMonitors.getRunningMonitor(destination);</span><br><span class="line">            <span class="keyword">if</span> (runningMonitor.isStart()) &#123;</span><br><span class="line">                runningMonitor.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">(String destination)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 目前任何配置变化，直接重启，简单处理</span></span><br><span class="line">        stop(destination);</span><br><span class="line">        start(destination);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>instanceConfigMonitors字段初始化源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">instanceConfigMonitors = MigrateMap.makeComputingMap(<span class="keyword">new</span> Function&lt;InstanceMode, InstanceConfigMonitor&gt;() &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> InstanceConfigMonitor <span class="title">apply</span><span class="params">(InstanceMode mode)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> scanInterval = Integer.valueOf(getProperty(properties, CanalConstants.CANAL_AUTO_SCAN_INTERVAL));</span><br><span class="line">           <span class="keyword">if</span> (mode.isSpring()) &#123;<span class="comment">//如果加载方式是spring，返回SpringInstanceConfigMonitor</span></span><br><span class="line">               SpringInstanceConfigMonitor monitor = <span class="keyword">new</span> SpringInstanceConfigMonitor();</span><br><span class="line">               monitor.setScanIntervalInSecond(scanInterval);</span><br><span class="line">               monitor.setDefaultAction(defaultAction);</span><br><span class="line">               <span class="comment">// 设置conf目录，默认是user.dir + conf目录组成</span></span><br><span class="line">               String rootDir = getProperty(properties, CanalConstants.CANAL_CONF_DIR);</span><br><span class="line">               <span class="keyword">if</span> (StringUtils.isEmpty(rootDir)) &#123;</span><br><span class="line">                   rootDir = <span class="string">"../conf"</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (StringUtils.equals(<span class="string">"otter-canal"</span>, System.getProperty(<span class="string">"appName"</span>))) &#123;</span><br><span class="line">                   monitor.setRootConf(rootDir);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// eclipse debug模式</span></span><br><span class="line">                   monitor.setRootConf(<span class="string">"src/main/resources/"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> monitor;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode.isManager()) &#123;<span class="comment">//如果加载方式是manager，返回ManagerInstanceConfigMonitor</span></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> ManagerInstanceConfigMonitor();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"unknow mode :"</span> + mode + <span class="string">" for monitor"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<p>可以看到instanceConfigMonitors也是根据mode属性，来采取不同的监控实现类SpringInstanceConfigMonitor 或者ManagerInstanceConfigMonitor，二者都实现了InstanceConfigMonitor接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InstanceConfigMonitor</span> <span class="keyword">extends</span> <span class="title">CanalLifeCycle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(String destination, InstanceAction action)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unregister</span><span class="params">(String destination)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当需要对一个destination进行监听时，调用register方法</p>
<p>当取消对一个destination监听时，调用unregister方法。</p>
<p>事实上，unregister方法在canal 内部并没有有任何地方被调用，也就是说，某个destination如果开启了autoScan=true，那么你是无法在运行时停止对其进行监控的。如果要停止，你可以选择将对应的目录删除。</p>
<p>InstanceConfigMonitor本身并不知道哪些canal instance需要进行监控，因为不同的canal instance，有的可能设置autoScan为true，另外一些可能设置为false。</p>
<p>在CanalConroller的start方法中，对于autoScan为true的destination，会调用InstanceConfigMonitor的register方法进行注册，此时InstanceConfigMonitor才会真正的对这个destination配置进行扫描监听。对于那些autoScan为false的destination，则不会进行监听。</p>
<p>目前SpringInstanceConfigMonitor对这两个方法都进行了实现，而ManagerInstanceConfigMonitor目前对这两个方法实现的都是空，需要开发者自己来实现。</p>
<p>在实现ManagerInstanceConfigMonitor时，可以参考SpringInstanceConfigMonitor。</p>
<p>此处不打算再继续进行分析SpringInstanceConfigMonitor的源码，因为逻辑很简单，感兴趣的读者可以自行查看SpringInstanceConfigMonitor 的scan方法，内部在什么情况下会回调defualtAction的start、stop、reload方法 。</p>
<h2 id="CanalController的start方法"><a href="#CanalController的start方法" class="headerlink" title="CanalController的start方法"></a>CanalController的start方法</h2><p>而ServerRunningMonitor的start方法，是在CanalController中的start方法中被调用的，CanalController中的start方法是在CanalLauncher中被调用的。</p>
<p>com.alibaba.otter.canal.deployer.CanalController#start</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"## start the canal server[&#123;&#125;:&#123;&#125;]"</span>, ip, port);</span><br><span class="line">        <span class="comment">// 创建整个canal的工作节点 :/otter/canal/cluster/&#123;0&#125;</span></span><br><span class="line">        <span class="keyword">final</span> String path = ZookeeperPathUtils.getCanalClusterNode(ip + <span class="string">":"</span> + port);</span><br><span class="line">        initCid(path);</span><br><span class="line">        <span class="keyword">if</span> (zkclientx != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.zkclientx.subscribeStateChanges(<span class="keyword">new</span> IZkStateListener() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleStateChanged</span><span class="params">(KeeperState state)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNewSession</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    initCid(path);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 优先启动embeded服务</span></span><br><span class="line">        embededCanalServer.start();</span><br><span class="line">        <span class="comment">//启动不是lazy模式的CanalInstance，通过迭代instanceConfigs，根据destination获取对应的ServerRunningMonitor，然后逐一启动</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, InstanceConfig&gt; entry : instanceConfigs.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">final</span> String destination = entry.getKey();</span><br><span class="line">            InstanceConfig config = entry.getValue();</span><br><span class="line">            <span class="comment">// 如果destination对应的CanalInstance没有启动，则进行启动</span></span><br><span class="line">            <span class="keyword">if</span> (!embededCanalServer.isStart(destination)) &#123;</span><br><span class="line">                ServerRunningMonitor runningMonitor = ServerRunningMonitors.getRunningMonitor(destination);</span><br><span class="line">                <span class="comment">//如果不是lazy，lazy模式需要等到第一次有客户端请求才会启动</span></span><br><span class="line">                <span class="keyword">if</span> (!config.getLazy() &amp;&amp; !runningMonitor.isStart()) &#123;</span><br><span class="line">                    runningMonitor.start();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (autoScan) &#123;</span><br><span class="line">                instanceConfigMonitors.get(config.getMode()).register(destination, defaultAction);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (autoScan) &#123;<span class="comment">//启动配置文件自动检测机制</span></span><br><span class="line">            instanceConfigMonitors.get(globalInstanceConfig.getMode()).start();</span><br><span class="line">            <span class="keyword">for</span> (InstanceConfigMonitor monitor : instanceConfigMonitors.values()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!monitor.isStart()) &#123;</span><br><span class="line">                    monitor.start();<span class="comment">//启动monitor</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 启动网络接口，监听客户端请求</span></span><br><span class="line">        canalServer.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>deployer模块的主要作用：</p>
<ul>
<li>读取canal.properties，确定canal instance的配置加载方式</li>
<li>确定canal instance的启动方式：独立启动或者集群方式启动</li>
<li>监听canal instance的配置的变化，动态停止、启动或新增</li>
<li>启动canal server，监听客户端请求</li>
</ul>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="http://code-monkey.top">Anthon</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="http://code-monkey.top/2020/02/06/CANAL源码解析-deployer模块/">http://code-monkey.top/2020/02/06/CANAL源码解析-deployer模块/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/canal/">canal</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
    
      <a class="next" href="/2020/02/06/CANAL源码解析-启动流程/">
        <span class="next-text nav-default">CANAL源码解析-启动流程</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:tanghuaidong@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/tangboy" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
        
          <a href="https://www.zhihu.com/people/tang-huai-dong/activities" class="iconfont icon-zhihu" title="zhihu"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    
      
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2020

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Anthon</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  

  



    
  



  
  





  
    <script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

  
    <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.10.1"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

  </body>
</html>
