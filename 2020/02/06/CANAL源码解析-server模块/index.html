<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta name="generator" content="Hexo 3.8.0">
    
<!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="CANAL源码解析-server模块">




  <meta name="keywords" content="canal, Anthon">










  <link rel="alternate" href="/default" title="Anthon">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.10.1">



<link rel="canonical" href="http://code-monkey.top/2020/02/06/CANAL源码解析-server模块/">



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">




  <link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css">



<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.10.1">



  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":true};
</script>

    <title> CANAL源码解析-server模块 - Anthon </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="mobile-header-logo">
    <a href="/." class="logo">Anthon</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Anthon</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          CANAL源码解析-server模块
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-02-06
        </span>
        
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#CanalServer接口"><span class="toc-text">CanalServer接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CanalServerWithNetty"><span class="toc-text">CanalServerWithNetty</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#start方法"><span class="toc-text">start方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SessionHandler"><span class="toc-text">SessionHandler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CanalServerWithEmbeded"><span class="toc-text">CanalServerWithEmbeded</span></a></li></ol>
    </div>
  </div>



    <div class="post-content">
      
        <p>server模块的核心接口是CanalServer，其有2个实现类CanalServerWithNetty、CanalServerWithEmbeded。关于CanalServer，官方文档中有有以下描述：</p>
<img src="/2020/02/06/CANAL源码解析-server模块/1.png">
<p>下图是笔者对官方文档的进一步描述：</p>
<img src="/2020/02/06/CANAL源码解析-server模块/2.png">
<a id="more"></a>
<p><strong>左边的图</strong></p>
<p>表示的是Canal独立部署。不同的应用通过canal client与canal server进行通信，所有的canal client的请求统一由CanalServerWithNetty接受，之后CanalServerWithNetty会将客户端请求派给CanalServerWithEmbeded 进行真正的处理。CannalServerWithEmbeded内部维护了多个canal instance，每个canal instance伪装成不同的mysql实例的slave，而CanalServerWithEmbeded会根据客户端请求携带的destination参数确定要由哪一个canal instance为其提供服务。</p>
<p><strong>右边的图</strong></p>
<p>是直接在应用中嵌入CanalServerWithEmbeded，不需要独立部署canal。很明显，网络通信环节少了，同步binlog信息的效率肯定更高。但是对于使用者的技术要求比较高。在应用中，我们可以通过CanalServerWithEmbeded.instance()方法来获得CanalServerWithEmbeded实例，这一个单例。</p>
<p>整个server模块源码目录结构如下所示：</p>
<img src="/2020/02/06/CANAL源码解析-server模块/3.png">
<p>其中上面的红色框就是嵌入式实现，而下面的绿色框是基于Netty的实现。</p>
<p>看起来基于netty的实现代码虽然多一点，这其实只是幻觉，CanalServerWithNetty会将所有的请求委派给CanalServerWithEmbedded处理。</p>
<p>而内嵌的方式只有CanalServerWithEmbedded一个类， 是因为CanalServerWithEmbedded又要根据destination选择某个具体的CanalInstance来处理客户端请求，而CanalInstance的实现位于instance模块，我们将在之后分析。因此从canal server的角度来说，CanalServerWithEmbedded才是server模块真正的核心。</p>
<p>CanalServerWithNetty和CanalServerWithEmbedded都是单例的，提供了一个静态方法instance()获取对应的实例。回顾前一节分析CanalController源码时，在CanalController构造方法中准备CanalServer的相关代码，就是通过这两个静态方法获取对应的实例的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CanalController</span><span class="params">(<span class="keyword">final</span> Properties properties)</span></span>&#123;</span><br><span class="line">        ....</span><br><span class="line">     <span class="comment">// 准备canal server</span></span><br><span class="line">        ip = getProperty(properties, CanalConstants.CANAL_IP);</span><br><span class="line">        port = Integer.valueOf(getProperty(properties, CanalConstants.CANAL_PORT));</span><br><span class="line">        embededCanalServer = CanalServerWithEmbedded.instance();</span><br><span class="line">        embededCanalServer.setCanalInstanceGenerator(instanceGenerator);<span class="comment">// 设置自定义的instanceGenerator</span></span><br><span class="line">        canalServer = CanalServerWithNetty.instance();</span><br><span class="line">        canalServer.setIp(ip);</span><br><span class="line">        canalServer.setPort(port);</span><br><span class="line">       ....   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CanalServer接口"><a href="#CanalServer接口" class="headerlink" title="CanalServer接口"></a>CanalServer接口</h2><p>CanalServer接口继承了CanalLifeCycle接口，主要是为了重新定义start和stop方法，抛出CanalServerException。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CanalServer</span> <span class="keyword">extends</span> <span class="title">CanalLifeCycle</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> CanalServerException</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> CanalServerException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CanalServerWithNetty"><a href="#CanalServerWithNetty" class="headerlink" title="CanalServerWithNetty"></a>CanalServerWithNetty</h2><p>CanalServerWithNetty主要用于接受客户端的请求，然后将其委派给CanalServerWithEmbeded处理。下面的源码显示了CanalServerWithNetty种定义的字段和构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanalServerWithNetty</span> <span class="keyword">extends</span> <span class="title">AbstractCanalLifeCycle</span> <span class="keyword">implements</span> <span class="title">CanalServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//监听的所有客户端请求都会为派给CanalServerWithEmbedded处理 </span></span><br><span class="line">    <span class="keyword">private</span> CanalServerWithEmbedded embeddedServer;      <span class="comment">// 嵌入式server</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//监听的ip和port，client通过此ip和port与服务端通信</span></span><br><span class="line">    <span class="keyword">private</span> String                  ip;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>                     port;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//netty组件</span></span><br><span class="line">    <span class="keyword">private</span> Channel                 serverChannel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> ServerBootstrap         bootstrap     = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//....单例模式实现</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CanalServerWithNetty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//给embeddedServer赋值</span></span><br><span class="line">        <span class="keyword">this</span>.embeddedServer = CanalServerWithEmbedded.instance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//... start and stop method</span></span><br><span class="line">    <span class="comment">//...setters and getters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字段说明：</p>
<ul>
<li><strong>embeddedServer：</strong>因为CanalServerWithNetty需要将请求委派给CanalServerWithEmbeded处理，因此其维护了embeddedServer对象。</li>
<li><strong>ip、port：</strong>这是netty监听的网络ip和端口，client通过这个ip和端口与server通信</li>
<li><strong>serverChannel、bootstrap：</strong>这是netty的API。其中ServerBootstrap用于启动服务端，通过调用其bind方法，返回一个类型为Channel的serverChannel对象，代表服务端通道。</li>
</ul>
<h3 id="start方法"><a href="#start方法" class="headerlink" title="start方法"></a>start方法</h3><p>start方法中包含了netty启动的核心逻辑，如下所示：</p>
<p>com.alibaba.otter.canal.server.netty.CanalServerWithNetty#start</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.start();</span><br><span class="line">        <span class="comment">//优先启动内嵌的canal server，因为基于netty的实现需要将请求委派给其处理</span></span><br><span class="line">        <span class="keyword">if</span> (!embeddedServer.isStart()) &#123;</span><br><span class="line">            embeddedServer.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">/* 创建bootstrap实例，参数NioServerSocketChannelFactory也是Netty的API，其接受2个线程池参数</span></span><br><span class="line"><span class="comment">         其中第一个线程池是Accept线程池，第二个线程池是woker线程池，</span></span><br><span class="line"><span class="comment">         Accept线程池接收到client连接请求后，会将代表client的对象转发给worker线程池处理。</span></span><br><span class="line"><span class="comment">         这里属于netty的知识，不熟悉的用户暂时不必深究，简单认为netty使用线程来处理客户端的高并发请求即可。*/</span></span><br><span class="line">        <span class="keyword">this</span>.bootstrap = <span class="keyword">new</span> ServerBootstrap(<span class="keyword">new</span> NioServerSocketChannelFactory(Executors.newCachedThreadPool(),</span><br><span class="line">            Executors.newCachedThreadPool()));</span><br><span class="line">            </span><br><span class="line">        <span class="comment">/*pipeline实际上就是netty对客户端请求的处理器链，</span></span><br><span class="line"><span class="comment">        可以类比JAVA EE编程中Filter的责任链模式，上一个filter处理完成之后交给下一个filter处理，</span></span><br><span class="line"><span class="comment">        只不过在netty中，不再是filter，而是ChannelHandler。*/</span></span><br><span class="line">        bootstrap.setPipelineFactory(<span class="keyword">new</span> ChannelPipelineFactory() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> ChannelPipeline <span class="title">getPipeline</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                ChannelPipeline pipelines = Channels.pipeline();</span><br><span class="line">               <span class="comment">//主要是处理编码、解码。因为网路传输的传入的都是二进制流，FixedHeaderFrameDecoder的作用就是对其进行解析</span></span><br><span class="line">                pipelines.addLast(FixedHeaderFrameDecoder.class.getName(), <span class="keyword">new</span> FixedHeaderFrameDecoder());</span><br><span class="line">               <span class="comment">//处理client与server握手</span></span><br><span class="line">                pipelines.addLast(HandshakeInitializationHandler.class.getName(), <span class="keyword">new</span> HandshakeInitializationHandler());</span><br><span class="line">               <span class="comment">//client身份验证</span></span><br><span class="line">               pipelines.addLast(ClientAuthenticationHandler.class.getName(),</span><br><span class="line">                    <span class="keyword">new</span> ClientAuthenticationHandler(embeddedServer));</span><br><span class="line">                <span class="comment">//SessionHandler用于真正的处理客户端请求，是本文分析的重点</span></span><br><span class="line">               SessionHandler sessionHandler = <span class="keyword">new</span> SessionHandler(embeddedServer);</span><br><span class="line">                pipelines.addLast(SessionHandler.class.getName(), sessionHandler);</span><br><span class="line">                <span class="keyword">return</span> pipelines;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 启动，当bind方法被调用时，netty开始真正的监控某个端口，此时客户端对这个端口的请求可以被接受到</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(ip)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.serverChannel = bootstrap.bind(<span class="keyword">new</span> InetSocketAddress(<span class="keyword">this</span>.ip, <span class="keyword">this</span>.port));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.serverChannel = bootstrap.bind(<span class="keyword">new</span> InetSocketAddress(<span class="keyword">this</span>.port));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>关于stop方法无非是一些关闭操作，代码很简单，这里不做介绍。</p>
<h2 id="SessionHandler"><a href="#SessionHandler" class="headerlink" title="SessionHandler"></a>SessionHandler</h2><p> 很明显的，canal处理client请求的核心逻辑都在SessionHandler这个处理器中。注意其在实例化时，传入了embeddedServer对象，前面我们提过，CanalServerWithNetty要将请求委派给CanalServerWithEmbedded处理，显然SessionHandler也要维护embeddedServer实例。</p>
<p>这里我们主要分析SessionHandler的 messageReceived方法，这个方法表示接受到了一个客户端请求，我们主要看的是SessionHandler如何对客户端请求进行解析，然后委派给CanalServerWithEmbedded处理的。为了体现其转发请求处理的核心逻辑，以下代码省去了大量源码片段，如下</p>
<p>SessionHandler#messageReceived</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelHandler</span> </span>&#123;</span><br><span class="line">....</span><br><span class="line"><span class="comment">//messageReceived方法表示收到客户端请求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageReceived</span><span class="params">(ChannelHandlerContext ctx, MessageEvent e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">      <span class="comment">//根据客户端发送的网路通信包请求类型type，将请求委派embeddedServer处理</span></span><br><span class="line">        <span class="keyword">switch</span> (packet.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> SUBSCRIPTION:<span class="comment">//订阅请求</span></span><br><span class="line">                ...</span><br><span class="line">                embeddedServer.subscribe(clientIdentity);</span><br><span class="line">                         ...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> UNSUBSCRIPTION:<span class="comment">//取消订阅请求</span></span><br><span class="line">                ...</span><br><span class="line">                embeddedServer.unsubscribe(clientIdentity);</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> GET:<span class="comment">//获取binlog请求</span></span><br><span class="line">                ....</span><br><span class="line">                    <span class="keyword">if</span> (get.getTimeout() == -<span class="number">1</span>) &#123;<span class="comment">// 根据客户端是否指定了请求超时时间调用embeddedServer不同方法获取binlog</span></span><br><span class="line">                        message = embeddedServer.getWithoutAck(clientIdentity, get.getFetchSize());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ...</span><br><span class="line">                        message = embeddedServer.getWithoutAck(clientIdentity,</span><br><span class="line">                            get.getFetchSize(),</span><br><span class="line">                            get.getTimeout(),</span><br><span class="line">                            unit);</span><br><span class="line">                    &#125;</span><br><span class="line">                ...   </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLIENTACK:<span class="comment">//客户端消费成功ack请求</span></span><br><span class="line">               ...</span><br><span class="line">                  embeddedServer.ack(clientIdentity, ack.getBatchId());</span><br><span class="line">               ...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLIENTROLLBACK:<span class="comment">//客户端消费失败回滚请求</span></span><br><span class="line">                ...</span><br><span class="line">                    <span class="keyword">if</span> (rollback.getBatchId() == <span class="number">0L</span>) &#123;</span><br><span class="line">                        embeddedServer.rollback(clientIdentity);<span class="comment">// 回滚所有批次</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        embeddedServer.rollback(clientIdentity, rollback.getBatchId()); <span class="comment">// 只回滚单个批次</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:<span class="comment">//无法判断请求类型</span></span><br><span class="line">                NettyUtils.error(<span class="number">400</span>, MessageFormatter.format(<span class="string">"packet type=&#123;&#125; is NOT supported!"</span>, packet.getType())</span><br><span class="line">                    .getMessage(), ctx.getChannel(), <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 可以看到，SessionHandler对client请求进行解析后，根据请求类型，委派给CanalServerWithEmbedded的相应方法进行处理。因此核心逻辑都在CanalServerWithEmbedded中。</p>
<h2 id="CanalServerWithEmbeded"><a href="#CanalServerWithEmbeded" class="headerlink" title="CanalServerWithEmbeded"></a>CanalServerWithEmbeded</h2><p> CanalServerWithEmbedded实现了CanalServer和CanalService两个接口。其内部维护了一个Map，key为destination，value为对应的CanalInstance，根据客户端请求携带的destination参数将其转发到对应的CanalInstance上去处理</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanalServerWithEmbedded</span> <span class="keyword">extends</span> <span class="title">AbstractCanalLifeCycle</span> <span class="keyword">implements</span> <span class="title">CanalServer</span>, <span class="title">CanalService</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//key为destination，value为对应的CanalInstance。</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, CanalInstance&gt; canalInstances;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 对于CanalServer接口中定义的start和stop这两个方法实现比较简单，这里不再赘述。</p>
<p>在上面的SessionHandler源码分析中，我们已经看到，会根据请求报文的类型，会调用CanalServerWithEmbedded的相应方法，这些方法都定义在CanalService接口中，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CanalService</span> </span>&#123;</span><br><span class="line">   <span class="comment">//订阅</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ClientIdentity clientIdentity)</span> <span class="keyword">throws</span> CanalServerException</span>;</span><br><span class="line">   <span class="comment">//取消订阅</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(ClientIdentity clientIdentity)</span> <span class="keyword">throws</span> CanalServerException</span>;</span><br><span class="line">   <span class="comment">//比例获取数据，并自动自行ack</span></span><br><span class="line">    <span class="function">Message <span class="title">get</span><span class="params">(ClientIdentity clientIdentity, <span class="keyword">int</span> batchSize)</span> <span class="keyword">throws</span> CanalServerException</span>;</span><br><span class="line">   <span class="comment">//超时时间内批量获取数据，并自动进行ack</span></span><br><span class="line">    <span class="function">Message <span class="title">get</span><span class="params">(ClientIdentity clientIdentity, <span class="keyword">int</span> batchSize, Long timeout, TimeUnit unit)</span> <span class="keyword">throws</span> CanalServerException</span>;</span><br><span class="line">    <span class="comment">//批量获取数据，不进行ack</span></span><br><span class="line">    <span class="function">Message <span class="title">getWithoutAck</span><span class="params">(ClientIdentity clientIdentity, <span class="keyword">int</span> batchSize)</span> <span class="keyword">throws</span> CanalServerException</span>;</span><br><span class="line">   <span class="comment">//超时时间内批量获取数据，不进行ack</span></span><br><span class="line">    <span class="function">Message <span class="title">getWithoutAck</span><span class="params">(ClientIdentity clientIdentity, <span class="keyword">int</span> batchSize, Long timeout, TimeUnit unit)</span>                                                                                               <span class="keyword">throws</span> CanalServerException</span>;</span><br><span class="line">   <span class="comment">//ack某个批次的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ack</span><span class="params">(ClientIdentity clientIdentity, <span class="keyword">long</span> batchId)</span> <span class="keyword">throws</span> CanalServerException</span>;</span><br><span class="line">   <span class="comment">//回滚所有没有ack的批次的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(ClientIdentity clientIdentity)</span> <span class="keyword">throws</span> CanalServerException</span>;</span><br><span class="line">   <span class="comment">//回滚某个批次的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(ClientIdentity clientIdentity, Long batchId)</span> <span class="keyword">throws</span> CanalServerException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>细心地的读者会发现，每个方法中都包含了一个ClientIdentity类型参数，这就是客户端身份的标识。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientIdentity</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String destination;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">short</span>  clientId;</span><br><span class="line">    <span class="keyword">private</span> String filter;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CanalServerWithEmbedded就是根据ClientIdentity中的destination参数确定这个请求要交给哪个CanalInstance处理的。</p>
<p>下面一次分析每一个方法的作用：</p>
<p><strong>subscribe方法：</strong></p>
<p>subscribe主要用于处理客户端的订阅请求，目前情况下，一个CanalInstance只能由一个客户端订阅，不过可以重复订阅。订阅主要的处理步骤如下：</p>
<ol>
<li>根据客户端要订阅的destination，找到对应的CanalInstance</li>
<li>通过这个CanalInstance的CanalMetaManager组件记录下有客户端订阅。</li>
<li>获取客户端当前订阅位置(Position)。首先尝试从CanalMetaManager中获取，CanalMetaManager 中记录了某个client当前订阅binlog的位置信息。如果是第一次订阅，肯定无法获取到这个位置，则尝试从CanalEventStore中获取第一个binlog的位置。从CanalEventStore中获取binlog位置信息的逻辑是：CanalInstance一旦启动，就会立刻去拉取binlog，存储到CanalEventStore中，在第一次订阅的情况下，CanalEventStore中的第一条binlog的位置，就是当前客户端当前消费的开始位置。</li>
<li>通知CanalInstance订阅关系变化 </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端订阅，重复订阅时会更新对应的filter信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ClientIdentity clientIdentity)</span> <span class="keyword">throws</span> CanalServerException </span>&#123;</span><br><span class="line">    checkStart(clientIdentity.getDestination());</span><br><span class="line">    <span class="comment">//1、根据客户端要订阅的destination，找到对应的CanalInstance </span></span><br><span class="line">    CanalInstance canalInstance = canalInstances.get(clientIdentity.getDestination());</span><br><span class="line">    <span class="keyword">if</span> (!canalInstance.getMetaManager().isStart()) &#123;</span><br><span class="line">        canalInstance.getMetaManager().start();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//2、通过CanalInstance的CanalMetaManager组件进行元数据管理，记录一下当前这个CanalInstance有客户端在订阅</span></span><br><span class="line">    canalInstance.getMetaManager().subscribe(clientIdentity); <span class="comment">// 执行一下meta订阅</span></span><br><span class="line">  <span class="comment">//3、获取客户端当前订阅的binlog位置(Position)，首先尝试从CanalMetaManager中获取</span></span><br><span class="line">    Position position = canalInstance.getMetaManager().getCursor(clientIdentity);</span><br><span class="line">    <span class="keyword">if</span> (position == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="comment">//3.1 如果是第一次订阅，尝试从CanalEventStore中获取第一个binlog的位置，作为客户端订阅开始的位置。</span></span><br><span class="line">        position = canalInstance.getEventStore().getFirstPosition();<span class="comment">// 获取一下store中的第一条</span></span><br><span class="line">        <span class="keyword">if</span> (position != <span class="keyword">null</span>) &#123;</span><br><span class="line">            canalInstance.getMetaManager().updateCursor(clientIdentity, position); <span class="comment">// 更新一下cursor</span></span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">"subscribe successfully, &#123;&#125; with first position:&#123;&#125; "</span>, clientIdentity, position);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.info(<span class="string">"subscribe successfully, use last cursor position:&#123;&#125; "</span>, clientIdentity, position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4 通知下订阅关系变化</span></span><br><span class="line">    canalInstance.subscribeChange(clientIdentity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>unsubscribe方法：</strong></p>
<p>unsubscribe方法主要用于取消订阅关系。在下面的代码中，我们可以看到，其实就是找到CanalInstance对应的CanalMetaManager，调用其unsubscribe取消这个订阅记录。需要注意的是，取消订阅并不意味着停止CanalInstance。当某个客户端取消了订阅，还会有新的client来订阅这个CanalInstance，所以不能停。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取消订阅</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(ClientIdentity clientIdentity)</span> <span class="keyword">throws</span> CanalServerException </span>&#123;</span><br><span class="line">    CanalInstance canalInstance = canalInstances.get(clientIdentity.getDestination());</span><br><span class="line">    canalInstance.getMetaManager().unsubscribe(clientIdentity); <span class="comment">// 执行一下meta订阅</span></span><br><span class="line">    logger.info(<span class="string">"unsubscribe successfully, &#123;&#125;"</span>, clientIdentity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>listAllSubscribe方法：</strong>  </p>
<p>这一个管理方法，其作用是列出订阅某个destination的所有client。这里返回的是一个List<clientidentity>，不过我们已经多次提到，目前一个destination只能由一个client订阅。这里之所以返回一个list，是canal原先计划要支持多个client订阅同一个destination。不过，这个功能一直没有实现。所以List中，实际上只会包含一个ClientIdentity。 </clientidentity></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询所有的订阅信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ClientIdentity&gt; <span class="title">listAllSubscribe</span><span class="params">(String destination)</span> <span class="keyword">throws</span> CanalServerException </span>&#123;</span><br><span class="line">    CanalInstance canalInstance = canalInstances.get(destination);</span><br><span class="line">    <span class="keyword">return</span> canalInstance.getMetaManager().listAllSubscribeInfo(destination);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>listBatchIds方法:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询当前未被ack的batch列表，batchId会按照从小到大进行返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Long&gt; <span class="title">listBatchIds</span><span class="params">(ClientIdentity clientIdentity)</span> <span class="keyword">throws</span> CanalServerException </span>&#123;</span><br><span class="line">    checkStart(clientIdentity.getDestination());</span><br><span class="line">    checkSubscribe(clientIdentity);</span><br><span class="line">    CanalInstance canalInstance = canalInstances.get(clientIdentity.getDestination());</span><br><span class="line">    Map&lt;Long, PositionRange&gt; batchs = canalInstance.getMetaManager().listAllBatchs(clientIdentity);</span><br><span class="line">    List&lt;Long&gt; result = <span class="keyword">new</span> ArrayList&lt;Long&gt;(batchs.keySet());</span><br><span class="line">    Collections.sort(result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>getWithoutAck方法：</strong></p>
<p>getWithoutAck方法用于客户端获取binlog消息 ，一个获取一批(batch)的binlog，canal会为这批binlog生成一个唯一的batchId。客户端如果消费成功，则调用ack方法对这个批次进行确认。如果失败的话，可以调用rollback方法进行回滚。客户端可以连续多次调用getWithoutAck方法来获取binlog，在ack的时候，需要按照获取到binlog的先后顺序进行ack。如果后面获取的binlog被ack了，那么之前没有ack的binlog消息也会自动被ack。</p>
<p>getWithoutAck方法大致工作步骤如下所示：</p>
<ol>
<li>根据destination找到要从哪一个CanalInstance中获取binlog消息。</li>
<li>确定从哪一个位置(Position)开始继续消费binlog。通常情况下，这个信息是存储在CanalMetaManager中。特别的，在第一次获取的时候，CanalMetaManager 中还没有存储任何binlog位置信息。此时CanalEventStore中存储的第一条binlog位置，则应该client开始消费的位置。</li>
<li>根据Position从CanalEventStore中获取binlog。为了尽量提高效率，一般一次获取一批binlog，而不是获取一条。这个批次的大小(batchSize)由客户端指定。同时客户端可以指定超时时间，在超时时间内，如果获取到了batchSize的binlog，会立即返回。 如果超时了还没有获取到batchSize指定的binlog个数，也会立即返回。特别的，如果没有设置超时时间，如果没有获取到binlog也立即返回。</li>
<li>在CanalMetaManager中记录这个批次的binlog消息。CanalMetaManager会为获取到的这个批次的binlog生成一个唯一的batchId，batchId是递增的。如果binlog信息为空，则直接把batchId设置为-1。 </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Message <span class="title">getWithoutAck</span><span class="params">(ClientIdentity clientIdentity, <span class="keyword">int</span> batchSize)</span> <span class="keyword">throws</span> CanalServerException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getWithoutAck(clientIdentity, batchSize, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * 几种case:</span></span><br><span class="line"><span class="comment"> * a. 如果timeout为null，则采用tryGet方式，即时获取</span></span><br><span class="line"><span class="comment"> * b. 如果timeout不为null</span></span><br><span class="line"><span class="comment"> *    1. timeout为0，则采用get阻塞方式，获取数据，不设置超时，直到有足够的batchSize数据才返回</span></span><br><span class="line"><span class="comment"> *    2. timeout不为0，则采用get+timeout方式，获取数据，超时还没有batchSize足够的数据，有多少返回多少</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Message <span class="title">getWithoutAck</span><span class="params">(ClientIdentity clientIdentity, <span class="keyword">int</span> batchSize, Long timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">                                                                                                       <span class="keyword">throws</span> CanalServerException </span>&#123;</span><br><span class="line">    checkStart(clientIdentity.getDestination());</span><br><span class="line">    checkSubscribe(clientIdentity);</span><br><span class="line">      <span class="comment">// 1、根据destination找到要从哪一个CanalInstance中获取binlog消息</span></span><br><span class="line">    CanalInstance canalInstance = canalInstances.get(clientIdentity.getDestination());</span><br><span class="line">    <span class="keyword">synchronized</span> (canalInstance) &#123;</span><br><span class="line">        <span class="comment">//2、从CanalMetaManager中获取最后一个没有ack的binlog批次的位置信息。</span></span><br><span class="line">        PositionRange&lt;LogPosition&gt; positionRanges = canalInstance.getMetaManager().getLastestBatch(clientIdentity);</span><br><span class="line">   <span class="comment">//3 从CanalEventStore中获取binlog</span></span><br><span class="line">        Events&lt;Event&gt; events = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (positionRanges != <span class="keyword">null</span>) &#123; <span class="comment">// 3.1 如果从CanalMetaManager获取到了位置信息，从当前位置继续获取binlog</span></span><br><span class="line">            events = getEvents(canalInstance.getEventStore(), positionRanges.getStart(), batchSize, timeout, unit);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//3.2 如果没有获取到binlog位置信息，从当前store中的第一条开始获取</span></span><br><span class="line">            Position start = canalInstance.getMetaManager().getCursor(clientIdentity);</span><br><span class="line">            <span class="keyword">if</span> (start == <span class="keyword">null</span>) &#123; <span class="comment">// 第一次，还没有过ack记录，则获取当前store中的第一条</span></span><br><span class="line">                start = canalInstance.getEventStore().getFirstPosition();</span><br><span class="line">            &#125;</span><br><span class="line">      <span class="comment">// 从CanalEventStore中获取binlog消息</span></span><br><span class="line">            events = getEvents(canalInstance.getEventStore(), start, batchSize, timeout, unit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4 记录批次信息到CanalMetaManager中</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(events.getEvents())) &#123;</span><br><span class="line">          <span class="comment">//4.1 如果获取到的binlog消息为空，构造一个空的Message对象，将batchId设置为-1返回给客户端</span></span><br><span class="line">            logger.debug(<span class="string">"getWithoutAck successfully, clientId:&#123;&#125; batchSize:&#123;&#125; but result is null"</span>, <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">                    clientIdentity.getClientId(), batchSize &#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Message(-<span class="number">1</span>, <span class="keyword">new</span> ArrayList&lt;Entry&gt;()); <span class="comment">// 返回空包，避免生成batchId，浪费性能</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//4.2 如果获取到了binlog消息，将这个批次的binlog消息记录到CanalMetaMaager中，并生成一个唯一的batchId</span></span><br><span class="line">            Long batchId = canalInstance.getMetaManager().addBatch(clientIdentity, events.getPositionRange());</span><br><span class="line">            <span class="comment">//将Events转为Entry</span></span><br><span class="line">            List&lt;Entry&gt; entrys = Lists.transform(events.getEvents(), <span class="keyword">new</span> Function&lt;Event, Entry&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Entry <span class="title">apply</span><span class="params">(Event input)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> input.getEntry();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            logger.info(<span class="string">"getWithoutAck successfully, clientId:&#123;&#125; batchSize:&#123;&#125;  real size is &#123;&#125; and result is [batchId:&#123;&#125; , position:&#123;&#125;]"</span>,</span><br><span class="line">                clientIdentity.getClientId(),</span><br><span class="line">                batchSize,</span><br><span class="line">                entrys.size(),</span><br><span class="line">                batchId,</span><br><span class="line">                events.getPositionRange());</span><br><span class="line">            <span class="comment">//构造Message返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Message(batchId, entrys);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据不同的参数，选择不同的方式获取数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Events&lt;Event&gt; <span class="title">getEvents</span><span class="params">(CanalEventStore eventStore, Position start, <span class="keyword">int</span> batchSize, Long timeout,</span></span></span><br><span class="line"><span class="function"><span class="params">                                TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> eventStore.tryGet(start, batchSize);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> eventStore.get(start, batchSize);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> eventStore.get(start, batchSize, timeout, unit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CanalServerException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ack方法：</strong></p>
<p>ack方法时客户端用户确认某个批次的binlog消费成功。进行 batch id 的确认。确认之后，小于等于此 batchId 的 Message 都会被确认。注意：进行反馈时必须按照batchId的顺序进行ack(需有客户端保证)</p>
<p>ack时需要做以下几件事情：</p>
<ol>
<li>从CanalMetaManager中，移除这个批次的信息。在getWithoutAck方法中，将批次的信息记录到了CanalMetaManager中，ack时移除。</li>
<li>记录已经成功消费到的binlog位置，以便下一次获取的时候可以从这个位置开始，这是通过CanalMetaManager记录的。</li>
<li>从CanalEventStore中，将这个批次的binlog内容移除。因为已经消费成功，继续保存这些已经消费过的binlog没有任何意义，只会白白占用内存。 </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ack</span><span class="params">(ClientIdentity clientIdentity, <span class="keyword">long</span> batchId)</span> <span class="keyword">throws</span> CanalServerException </span>&#123;</span><br><span class="line">    checkStart(clientIdentity.getDestination());</span><br><span class="line">    checkSubscribe(clientIdentity);</span><br><span class="line">    CanalInstance canalInstance = canalInstances.get(clientIdentity.getDestination());</span><br><span class="line">    PositionRange&lt;LogPosition&gt; positionRanges = <span class="keyword">null</span>;</span><br><span class="line">   <span class="comment">//1 从CanalMetaManager中，移除这个批次的信息</span></span><br><span class="line">    positionRanges = canalInstance.getMetaManager().removeBatch(clientIdentity, batchId); <span class="comment">// 更新位置</span></span><br><span class="line">    <span class="keyword">if</span> (positionRanges == <span class="keyword">null</span>) &#123; <span class="comment">// 说明是重复的ack/rollback</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CanalServerException(String.format(<span class="string">"ack error , clientId:%s batchId:%d is not exist , please check"</span>,</span><br><span class="line">            clientIdentity.getClientId(),</span><br><span class="line">            batchId));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2、记录已经成功消费到的binlog位置，以便下一次获取的时候可以从这个位置开始，这是通过CanalMetaManager记录的</span></span><br><span class="line">    <span class="keyword">if</span> (positionRanges.getAck() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        canalInstance.getMetaManager().updateCursor(clientIdentity, positionRanges.getAck());</span><br><span class="line">        logger.info(<span class="string">"ack successfully, clientId:&#123;&#125; batchId:&#123;&#125; position:&#123;&#125;"</span>,</span><br><span class="line">            clientIdentity.getClientId(),</span><br><span class="line">            batchId,</span><br><span class="line">            positionRanges);</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">//3、从CanalEventStore中，将这个批次的binlog内容移除</span></span><br><span class="line">    canalInstance.getEventStore().ack(positionRanges.getEnd());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>rollback方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 回滚到未进行 &#123;<span class="doctag">@link</span> #ack&#125; 的地方，下次fetch的时候，可以从最后一个没有 &#123;<span class="doctag">@link</span> #ack&#125; 的地方开始拿</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">(ClientIdentity clientIdentity)</span> <span class="keyword">throws</span> CanalServerException </span>&#123;</span><br><span class="line">    checkStart(clientIdentity.getDestination());</span><br><span class="line">    CanalInstance canalInstance = canalInstances.get(clientIdentity.getDestination());</span><br><span class="line">    <span class="comment">// 因为存在第一次链接时自动rollback的情况，所以需要忽略未订阅</span></span><br><span class="line">    <span class="keyword">boolean</span> hasSubscribe = canalInstance.getMetaManager().hasSubscribe(clientIdentity);</span><br><span class="line">    <span class="keyword">if</span> (!hasSubscribe) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (canalInstance) &#123;</span><br><span class="line">        <span class="comment">// 清除batch信息</span></span><br><span class="line">        canalInstance.getMetaManager().clearAllBatchs(clientIdentity);</span><br><span class="line">        <span class="comment">// rollback eventStore中的状态信息</span></span><br><span class="line">        canalInstance.getEventStore().rollback();</span><br><span class="line">        logger.info(<span class="string">"rollback successfully, clientId:&#123;&#125;"</span>, <span class="keyword">new</span> Object[] &#123; clientIdentity.getClientId() &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 回滚到未进行 &#123;<span class="doctag">@link</span> #ack&#125; 的地方，下次fetch的时候，可以从最后一个没有 &#123;<span class="doctag">@link</span> #ack&#125; 的地方开始拿</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">(ClientIdentity clientIdentity, Long batchId)</span> <span class="keyword">throws</span> CanalServerException </span>&#123;</span><br><span class="line">    checkStart(clientIdentity.getDestination());</span><br><span class="line">    CanalInstance canalInstance = canalInstances.get(clientIdentity.getDestination());</span><br><span class="line">    <span class="comment">// 因为存在第一次链接时自动rollback的情况，所以需要忽略未订阅</span></span><br><span class="line">    <span class="keyword">boolean</span> hasSubscribe = canalInstance.getMetaManager().hasSubscribe(clientIdentity);</span><br><span class="line">    <span class="keyword">if</span> (!hasSubscribe) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (canalInstance) &#123;</span><br><span class="line">        <span class="comment">// 清除batch信息</span></span><br><span class="line">        PositionRange&lt;LogPosition&gt; positionRanges = canalInstance.getMetaManager().removeBatch(clientIdentity,</span><br><span class="line">            batchId);</span><br><span class="line">        <span class="keyword">if</span> (positionRanges == <span class="keyword">null</span>) &#123; <span class="comment">// 说明是重复的ack/rollback</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CanalServerException(String.format(<span class="string">"rollback error, clientId:%s batchId:%d is not exist , please check"</span>,</span><br><span class="line">                clientIdentity.getClientId(),</span><br><span class="line">                batchId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// lastRollbackPostions.put(clientIdentity,</span></span><br><span class="line">        <span class="comment">// positionRanges.getEnd());// 记录一下最后rollback的位置</span></span><br><span class="line">        <span class="comment">// TODO 后续rollback到指定的batchId位置</span></span><br><span class="line">        canalInstance.getEventStore().rollback();<span class="comment">// rollback</span></span><br><span class="line">                                                 <span class="comment">// eventStore中的状态信息</span></span><br><span class="line">        logger.info(<span class="string">"rollback successfully, clientId:&#123;&#125; batchId:&#123;&#125; position:&#123;&#125;"</span>,</span><br><span class="line">            clientIdentity.getClientId(),</span><br><span class="line">            batchId,</span><br><span class="line">            positionRanges);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>get方法：</strong></p>
<p>与getWithoutAck主要流程完全相同，唯一不同的是，在返回数据给用户前，直接进行了ack，而不管客户端消费是否成功</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Message <span class="title">get</span><span class="params">(ClientIdentity clientIdentity, <span class="keyword">int</span> batchSize)</span> <span class="keyword">throws</span> CanalServerException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(clientIdentity, batchSize, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 几种case:</span></span><br><span class="line"><span class="comment"> * a. 如果timeout为null，则采用tryGet方式，即时获取</span></span><br><span class="line"><span class="comment"> * b. 如果timeout不为null</span></span><br><span class="line"><span class="comment"> *    1. timeout为0，则采用get阻塞方式，获取数据，不设置超时，直到有足够的batchSize数据才返回</span></span><br><span class="line"><span class="comment"> *    2. timeout不为0，则采用get+timeout方式，获取数据，超时还没有batchSize足够的数据，有多少返回多少</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Message <span class="title">get</span><span class="params">(ClientIdentity clientIdentity, <span class="keyword">int</span> batchSize, Long timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">                                                                                             <span class="keyword">throws</span> CanalServerException </span>&#123;</span><br><span class="line">    checkStart(clientIdentity.getDestination());</span><br><span class="line">    checkSubscribe(clientIdentity);</span><br><span class="line">    CanalInstance canalInstance = canalInstances.get(clientIdentity.getDestination());</span><br><span class="line">    <span class="keyword">synchronized</span> (canalInstance) &#123;</span><br><span class="line">        <span class="comment">// 获取到流式数据中的最后一批获取的位置</span></span><br><span class="line">        PositionRange&lt;LogPosition&gt; positionRanges = canalInstance.getMetaManager().getLastestBatch(clientIdentity);</span><br><span class="line">        <span class="keyword">if</span> (positionRanges != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CanalServerException(String.format(<span class="string">"clientId:%s has last batch:[%s] isn't ack , maybe loss data"</span>,</span><br><span class="line">                clientIdentity.getClientId(),</span><br><span class="line">                positionRanges));</span><br><span class="line">        &#125;</span><br><span class="line">        Events&lt;Event&gt; events = <span class="keyword">null</span>;</span><br><span class="line">        Position start = canalInstance.getMetaManager().getCursor(clientIdentity);</span><br><span class="line">        events = getEvents(canalInstance.getEventStore(), start, batchSize, timeout, unit);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(events.getEvents())) &#123;</span><br><span class="line">            logger.debug(<span class="string">"get successfully, clientId:&#123;&#125; batchSize:&#123;&#125; but result is null"</span>, <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">                    clientIdentity.getClientId(), batchSize &#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Message(-<span class="number">1</span>, <span class="keyword">new</span> ArrayList&lt;Entry&gt;()); <span class="comment">// 返回空包，避免生成batchId，浪费性能</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 记录到流式信息</span></span><br><span class="line">            Long batchId = canalInstance.getMetaManager().addBatch(clientIdentity, events.getPositionRange());</span><br><span class="line">            List&lt;Entry&gt; entrys = Lists.transform(events.getEvents(), <span class="keyword">new</span> Function&lt;Event, Entry&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Entry <span class="title">apply</span><span class="params">(Event input)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> input.getEntry();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            logger.info(<span class="string">"get successfully, clientId:&#123;&#125; batchSize:&#123;&#125; real size is &#123;&#125; and result is [batchId:&#123;&#125; , position:&#123;&#125;]"</span>,</span><br><span class="line">                clientIdentity.getClientId(),</span><br><span class="line">                batchSize,</span><br><span class="line">                entrys.size(),</span><br><span class="line">                batchId,</span><br><span class="line">                events.getPositionRange());</span><br><span class="line">            <span class="comment">// 直接提交ack</span></span><br><span class="line">            ack(clientIdentity, batchId);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Message(batchId, entrys);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="http://code-monkey.top">Anthon</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="http://code-monkey.top/2020/02/06/CANAL源码解析-server模块/">http://code-monkey.top/2020/02/06/CANAL源码解析-server模块/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/canal/">canal</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
    
      <a class="next" href="/2020/02/06/CANAL源码解析-deployer模块/">
        <span class="next-text nav-default">CANAL源码解析-deployer模块</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:tanghuaidong@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/tangboy" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
        
          <a href="https://www.zhihu.com/people/tang-huai-dong/activities" class="iconfont icon-zhihu" title="zhihu"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    
      
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2020

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Anthon</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  

  



    
  



  
  





  
    <script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

  
    <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.10.1"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

  </body>
</html>
